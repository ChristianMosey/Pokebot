"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AudioFilters: () => AudioFilters,
  BaseExtractor: () => BaseExtractor,
  ErrorStatusCode: () => ErrorStatusCode,
  ExtractorExecutionContext: () => ExtractorExecutionContext,
  FFMPEG_ARGS_PIPED: () => FFMPEG_ARGS_PIPED,
  FFMPEG_ARGS_STRING: () => FFMPEG_ARGS_STRING,
  Player: () => Player,
  PlayerError: () => PlayerError,
  Playlist: () => Playlist,
  QueryResolver: () => QueryResolver,
  QueryType: () => QueryType,
  Queue: () => Queue,
  QueueRepeatMode: () => QueueRepeatMode,
  StreamDispatcher: () => StreamDispatcher,
  Track: () => Track,
  Util: () => Util,
  VoiceUtils: () => VoiceUtils,
  VolumeTransformer: () => VolumeTransformer,
  createFFmpegStream: () => createFFmpegStream,
  version: () => version
});
module.exports = __toCommonJS(src_exports);

// src/VoiceInterface/VolumeTransformer.ts
var import_stream = require("stream");
var VolumeTransformer = class extends import_stream.Transform {
  constructor(options = {}) {
    super(options);
    switch (options.type) {
      case "s16le":
        this._readInt = (buffer, index) => buffer.readInt16LE(index);
        this._writeInt = (buffer, int, index) => buffer.writeInt16LE(int, index);
        this._bits = 16;
        break;
      case "s16be":
        this._readInt = (buffer, index) => buffer.readInt16BE(index);
        this._writeInt = (buffer, int, index) => buffer.writeInt16BE(int, index);
        this._bits = 16;
        break;
      case "s32le":
        this._readInt = (buffer, index) => buffer.readInt32LE(index);
        this._writeInt = (buffer, int, index) => buffer.writeInt32LE(int, index);
        this._bits = 32;
        break;
      case "s32be":
        this._readInt = (buffer, index) => buffer.readInt32BE(index);
        this._writeInt = (buffer, int, index) => buffer.writeInt32BE(int, index);
        this._bits = 32;
        break;
      default:
        throw new Error("VolumeTransformer type should be one of s16le, s16be, s32le, s32be");
    }
    this.type = options.type;
    this._bytes = this._bits / 8;
    this._extremum = Math.pow(2, this._bits - 1);
    this.volume = Number.isNaN(options.volume) ? 1 : Number(options.volume);
    if (!Number.isFinite(this.volume))
      this.volume = 1;
    this._targetVolume = this.volume;
    this._chunk = Buffer.alloc(0);
    this._smoothing = options.smoothness || 0;
  }
  _readInt(buffer, index) {
    return index;
  }
  _writeInt(buffer, int, index) {
    return index;
  }
  _applySmoothness() {
    if (this.volume < this._targetVolume) {
      this.volume = this.volume + this._smoothing >= this._targetVolume ? this._targetVolume : this.volume + this._smoothing;
    } else if (this.volume > this._targetVolume) {
      this.volume = this.volume - this._smoothing <= this._targetVolume ? this._targetVolume : this.volume - this._smoothing;
    }
  }
  _transform(chunk, encoding, done) {
    if (this.smoothingEnabled() && this.volume !== this._targetVolume)
      this._applySmoothness();
    if (this.volume === 1) {
      this.push(chunk);
      return done();
    }
    const { _bytes, _extremum } = this;
    chunk = this._chunk = Buffer.concat([this._chunk, chunk]);
    if (chunk.length < _bytes)
      return done();
    const complete = Math.floor(chunk.length / _bytes) * _bytes;
    for (let i = 0; i < complete; i += _bytes) {
      const int = Math.min(_extremum - 1, Math.max(-_extremum, Math.floor(this.volume * this._readInt(chunk, i))));
      this._writeInt(chunk, int, i);
    }
    this._chunk = chunk.slice(complete);
    this.push(chunk.slice(0, complete));
    return done();
  }
  _destroy(err, cb) {
    super._destroy(err, cb);
    this._chunk = null;
  }
  setVolume(volume) {
    if (Number.isNaN(volume))
      volume = 1;
    if (typeof volume !== "number")
      volume = Number(volume);
    if (!Number.isFinite(volume))
      volume = volume < 0 ? 0 : 1;
    this._targetVolume = volume;
    if (this._smoothing <= 0)
      this.volume = volume;
  }
  setVolumeDecibels(db) {
    this.setVolume(Math.pow(10, db / 20));
  }
  setVolumeLogarithmic(value) {
    this.setVolume(Math.pow(value, 1.660964));
  }
  get volumeDecibels() {
    return Math.log10(this.volume) * 20;
  }
  get volumeLogarithmic() {
    return Math.pow(this.volume, 1 / 1.660964);
  }
  get smoothness() {
    return this._smoothing;
  }
  setSmoothness(smoothness) {
    this._smoothing = smoothness;
  }
  smoothingEnabled() {
    return typeof this._smoothing === "number" && !Number.isNaN(this._smoothing) && Number.isFinite(this._smoothing) && this._smoothing > 0;
  }
  get hasSmoothness() {
    return true;
  }
  static get hasSmoothing() {
    return true;
  }
};
__name(VolumeTransformer, "VolumeTransformer");

// src/smoothVolume.ts
if (!("DISABLE_DISCORD_PLAYER_SMOOTH_VOLUME" in process.env)) {
  try {
    const mod = require("prism-media");
    if (typeof mod.VolumeTransformer.hasSmoothing !== "boolean") {
      Reflect.set(mod, "VolumeTransformer", VolumeTransformer);
    }
  } catch {
  }
}

// src/index.ts
var import_discord4 = require("discord.js");

// src/utils/AudioFilters.ts
var bass = /* @__PURE__ */ __name((g) => `bass=g=${g}:f=110:w=0.3`, "bass");
var _AudioFilters = class {
  constructor() {
    return _AudioFilters;
  }
  static get(name) {
    return this.filters[name];
  }
  static has(name) {
    return name in this.filters;
  }
  static *[Symbol.iterator]() {
    for (const [k, v] of Object.entries(this.filters)) {
      yield { name: k, value: v };
    }
  }
  static get names() {
    return Object.keys(this.filters);
  }
  static get length() {
    return this.names.length;
  }
  static toString() {
    return this.names.map((m) => this[m]).join(",");
  }
  static create(filters) {
    if (!filters || !Array.isArray(filters))
      return this.toString();
    return filters.filter((predicate) => typeof predicate === "string").map((m) => this.get(m)).join(",");
  }
  static define(filterName, value) {
    this.filters[filterName] = value;
  }
  static defineBulk(filtersArray) {
    filtersArray.forEach((arr) => this.define(arr.name, arr.value));
  }
};
var AudioFilters = _AudioFilters;
__name(AudioFilters, "AudioFilters");
AudioFilters.filters = {
  bassboost_low: bass(15),
  bassboost: bass(20),
  bassboost_high: bass(30),
  "8D": "apulsator=hz=0.09",
  vaporwave: "aresample=48000,asetrate=48000*0.8",
  nightcore: "aresample=48000,asetrate=48000*1.25",
  phaser: "aphaser=in_gain=0.4",
  tremolo: "tremolo",
  vibrato: "vibrato=f=6.5",
  reverse: "areverse",
  treble: "treble=g=5",
  normalizer2: "dynaudnorm=g=101",
  normalizer: "acompressor",
  surrounding: "surround",
  pulsator: "apulsator=hz=1",
  subboost: "asubboost",
  karaoke: "stereotools=mlev=0.03",
  flanger: "flanger",
  gate: "agate",
  haas: "haas",
  mcompand: "mcompand",
  mono: "pan=mono|c0=.5*c0+.5*c1",
  mstlr: "stereotools=mode=ms>lr",
  mstrr: "stereotools=mode=ms>rr",
  compressor: "compand=points=-80/-105|-62/-80|-15.4/-15.4|0/-12|20/-7.6",
  expander: "compand=attacks=0:points=-80/-169|-54/-80|-49.5/-64.6|-41.1/-41.1|-25.8/-15|-10.8/-4.5|0/0|20/8.3",
  softlimiter: "compand=attacks=0:points=-80/-80|-12.4/-12.4|-6/-8|0/-6.8|20/-2.8",
  chorus: "chorus=0.7:0.9:55:0.4:0.25:2",
  chorus2d: "chorus=0.6:0.9:50|60:0.4|0.32:0.25|0.4:2|1.3",
  chorus3d: "chorus=0.5:0.9:50|60|40:0.4|0.32|0.3:0.25|0.4|0.3:2|2.3|1.3",
  fadein: "afade=t=in:ss=0:d=10",
  dim: `afftfilt="'real=re * (1-clip((b/nb)*b,0,1))':imag='im * (1-clip((b/nb)*b,0,1))'"`,
  earrape: "channelsplit,sidechaingate=level_in=64"
};
var AudioFilters_default = AudioFilters;

// src/extractors/BaseExtractor.ts
var BaseExtractor = class {
  constructor(context) {
    this.context = context;
  }
  get identifier() {
    return this.constructor.identifier;
  }
  async activate() {
    return;
  }
  async deactivate() {
    return;
  }
  async validate(query, type) {
    return false;
  }
  async stream(info) {
    throw new Error("Not Implemented");
  }
  async handle(query, context) {
    throw new Error("Not Implemented");
  }
  handlePostStream(stream, next) {
    return next(null, stream);
  }
  emit(event, ...args) {
    return this.context.player.emit(event, ...args);
  }
};
__name(BaseExtractor, "BaseExtractor");
BaseExtractor.identifier = "com.discord-player.extractor";

// src/extractors/ExtractorExecutionContext.ts
var import_utils = require("@discord-player/utils");
var ExtractorExecutionContext = class {
  constructor(player) {
    this.player = player;
    this.store = new import_utils.Collection();
  }
  isRegistered(identifier) {
    return this.store.has(identifier);
  }
  get size() {
    return this.store.size;
  }
  get(identifier) {
    return this.store.get(identifier);
  }
  async register(_extractor) {
    if (typeof _extractor.identifier !== "string" || this.store.has(_extractor.identifier))
      return;
    const extractor = new _extractor(this);
    try {
      this.store.set(_extractor.identifier, extractor);
      await extractor.activate();
    } catch {
      this.store.delete(_extractor.identifier);
    }
  }
  async unregister(_extractor) {
    const extractor = typeof _extractor === "string" ? this.store.get(_extractor) : this.store.find((r) => r === _extractor);
    if (!extractor)
      return;
    try {
      const key = extractor.identifier || this.store.findKey((e) => e === extractor);
      this.store.delete(key);
      await extractor.deactivate();
    } catch {
    }
  }
  async unregisterAll() {
    try {
      await Promise.all(
        this.store.map((e, k) => {
          this.store.delete(k);
          return e.deactivate();
        })
      );
    } catch {
    }
  }
  async run(fn) {
    for (const ext of this.store.values()) {
      const result = await fn(ext).catch(() => {
        return false;
      });
      if (result)
        return {
          extractor: ext,
          result
        };
    }
    return null;
  }
};
__name(ExtractorExecutionContext, "ExtractorExecutionContext");

// src/Structures/Playlist.ts
var Playlist = class {
  constructor(player, data) {
    this.player = player;
    this.tracks = data.tracks ?? [];
    this.author = data.author;
    this.description = data.description;
    this.thumbnail = data.thumbnail;
    this.type = data.type;
    this.source = data.source;
    this.id = data.id;
    this.url = data.url;
    this.title = data.title;
  }
  *[Symbol.iterator]() {
    yield* this.tracks;
  }
  toJSON(withTracks = true) {
    const payload = {
      id: this.id,
      url: this.url,
      title: this.title,
      description: this.description,
      thumbnail: this.thumbnail,
      type: this.type,
      source: this.source,
      author: this.author,
      tracks: []
    };
    if (withTracks)
      payload.tracks = this.tracks.map((m) => m.toJSON(true));
    return payload;
  }
};
__name(Playlist, "Playlist");

// src/Player.ts
var import_discord3 = require("discord.js");
var import_tiny_typed_emitter2 = require("tiny-typed-emitter");

// src/Structures/Queue.ts
var import_discord2 = require("discord.js");

// src/Structures/Track.ts
var import_discord = require("discord.js");
var Track = class {
  constructor(player, data) {
    this.requestedBy = null;
    this.queryType = null;
    this.raw = {};
    this.id = import_discord.SnowflakeUtil.generate().toString();
    Object.defineProperty(this, "player", { value: player, enumerable: false });
    void this._patch(data);
  }
  _patch(data) {
    this.title = (0, import_discord.escapeMarkdown)(data.title ?? "");
    this.author = data.author ?? "";
    this.url = data.url ?? "";
    this.thumbnail = data.thumbnail ?? "";
    this.duration = data.duration ?? "";
    this.views = data.views ?? 0;
    this.queryType = data.queryType;
    this.requestedBy = data.requestedBy || null;
    this.playlist = data.playlist;
    Object.defineProperty(this, "raw", { value: Object.assign({}, { source: data.raw?.source ?? data.source }, data.raw ?? data), enumerable: false });
  }
  get queue() {
    return this.player.queues.find((q) => q.tracks.some((ab) => ab.id === this.id));
  }
  get durationMS() {
    const times = /* @__PURE__ */ __name((n, t) => {
      let tn = 1;
      for (let i = 0; i < t; i++)
        tn *= n;
      return t <= 0 ? 1e3 : tn * 1e3;
    }, "times");
    return this.duration.split(":").reverse().map((m, i) => parseInt(m) * times(60, i)).reduce((a, c) => a + c, 0);
  }
  get source() {
    return this.raw.source ?? "arbitrary";
  }
  toString() {
    return `${this.title} by ${this.author}`;
  }
  toJSON(hidePlaylist) {
    return {
      id: this.id,
      title: this.title,
      description: this.description,
      author: this.author,
      url: this.url,
      thumbnail: this.thumbnail,
      duration: this.duration,
      durationMS: this.durationMS,
      views: this.views,
      requestedBy: this.requestedBy?.id || null,
      playlist: hidePlaylist ? null : this.playlist?.toJSON() ?? null
    };
  }
};
__name(Track, "Track");
var Track_default = Track;

// src/types/types.ts
var QueryType = {
  AUTO: "auto",
  YOUTUBE: "youtube",
  YOUTUBE_PLAYLIST: "youtubePlaylist",
  SOUNDCLOUD_TRACK: "soundcloudTrack",
  SOUNDCLOUD_PLAYLIST: "soundcloudPlaylist",
  SOUNDCLOUD: "soundcloud",
  SPOTIFY_SONG: "spotifySong",
  SPOTIFY_ALBUM: "spotifyAlbum",
  SPOTIFY_PLAYLIST: "spotifyPlaylist",
  FACEBOOK: "facebook",
  VIMEO: "vimeo",
  ARBITRARY: "arbitrary",
  REVERBNATION: "reverbnation",
  YOUTUBE_SEARCH: "youtubeSearch",
  YOUTUBE_VIDEO: "youtubeVideo",
  SOUNDCLOUD_SEARCH: "soundcloudSearch",
  APPLE_MUSIC_SONG: "appleMusicSong",
  APPLE_MUSIC_ALBUM: "appleMusicAlbum",
  APPLE_MUSIC_PLAYLIST: "appleMusicPlaylist",
  FILE: "file"
};
var QueueRepeatMode = /* @__PURE__ */ ((QueueRepeatMode2) => {
  QueueRepeatMode2[QueueRepeatMode2["OFF"] = 0] = "OFF";
  QueueRepeatMode2[QueueRepeatMode2["TRACK"] = 1] = "TRACK";
  QueueRepeatMode2[QueueRepeatMode2["QUEUE"] = 2] = "QUEUE";
  QueueRepeatMode2[QueueRepeatMode2["AUTOPLAY"] = 3] = "AUTOPLAY";
  return QueueRepeatMode2;
})(QueueRepeatMode || {});

// src/Structures/Queue.ts
var import_voice = require("@discordjs/voice");

// src/utils/Util.ts
var import_promises = require("timers/promises");
var Util = class {
  constructor() {
  }
  static durationString(durObj) {
    return Object.values(durObj).map((m) => isNaN(m) ? 0 : m).join(":");
  }
  static parseMS(milliseconds) {
    if (isNaN(milliseconds))
      milliseconds = 0;
    const round = milliseconds > 0 ? Math.floor : Math.ceil;
    return {
      days: round(milliseconds / 864e5),
      hours: round(milliseconds / 36e5) % 24,
      minutes: round(milliseconds / 6e4) % 60,
      seconds: round(milliseconds / 1e3) % 60
    };
  }
  static buildTimeCode(duration) {
    const items = Object.keys(duration);
    const required = ["days", "hours", "minutes", "seconds"];
    const parsed = items.filter((x) => required.includes(x)).map((m) => duration[m]);
    const final = parsed.slice(parsed.findIndex((x) => x !== 0)).map((x) => x.toString().padStart(2, "0")).join(":");
    return final.length <= 3 ? `0:${final.padStart(2, "0") || 0}` : final;
  }
  static last(arr) {
    if (!Array.isArray(arr))
      return arr;
    return arr[arr.length - 1];
  }
  static isVoiceEmpty(channel) {
    return channel.members.filter((member) => !member.user.bot).size === 0;
  }
  static require(id) {
    try {
      return require(id);
    } catch {
      return null;
    }
  }
  static wait(time) {
    return (0, import_promises.setTimeout)(time, void 0, { ref: false });
  }
  static noop() {
  }
  static async getFetch() {
    if ("fetch" in globalThis)
      return globalThis.fetch;
    for (const lib of ["node-fetch", "undici"]) {
      try {
        return await import(lib).then((res) => res.fetch || res.default?.fetch || res.default);
      } catch {
        try {
          const res = require(lib);
          if (res)
            return res.fetch || res.default?.fetch || res.default;
        } catch {
        }
      }
    }
  }
};
__name(Util, "Util");

// src/Structures/PlayerError.ts
var ErrorStatusCode = /* @__PURE__ */ ((ErrorStatusCode2) => {
  ErrorStatusCode2["STREAM_ERROR"] = "StreamError";
  ErrorStatusCode2["AUDIO_PLAYER_ERROR"] = "AudioPlayerError";
  ErrorStatusCode2["PLAYER_ERROR"] = "PlayerError";
  ErrorStatusCode2["NO_AUDIO_RESOURCE"] = "NoAudioResource";
  ErrorStatusCode2["UNKNOWN_GUILD"] = "UnknownGuild";
  ErrorStatusCode2["INVALID_ARG_TYPE"] = "InvalidArgType";
  ErrorStatusCode2["UNKNOWN_EXTRACTOR"] = "UnknownExtractor";
  ErrorStatusCode2["INVALID_EXTRACTOR"] = "InvalidExtractor";
  ErrorStatusCode2["INVALID_CHANNEL_TYPE"] = "InvalidChannelType";
  ErrorStatusCode2["INVALID_TRACK"] = "InvalidTrack";
  ErrorStatusCode2["UNKNOWN_REPEAT_MODE"] = "UnknownRepeatMode";
  ErrorStatusCode2["TRACK_NOT_FOUND"] = "TrackNotFound";
  ErrorStatusCode2["NO_CONNECTION"] = "NoConnection";
  ErrorStatusCode2["DESTROYED_QUEUE"] = "DestroyedQueue";
  return ErrorStatusCode2;
})(ErrorStatusCode || {});
var PlayerError = class extends Error {
  constructor(message, code = "PlayerError" /* PLAYER_ERROR */) {
    super();
    this.createdAt = new Date();
    this.message = `[${code}] ${message}`;
    this.statusCode = code;
    this.name = code;
    Error.captureStackTrace(this);
  }
  get createdTimestamp() {
    return this.createdAt.getTime();
  }
  valueOf() {
    return this.statusCode;
  }
  toJSON() {
    return {
      stack: this.stack,
      code: this.statusCode,
      message: this.message,
      created: this.createdTimestamp
    };
  }
  toString() {
    return this.stack;
  }
};
__name(PlayerError, "PlayerError");

// src/utils/FFmpegStream.ts
var import_prism_media = require("prism-media");
function FFMPEG_ARGS_STRING(stream, fmt) {
  return [
    "-reconnect",
    "1",
    "-reconnect_streamed",
    "1",
    "-reconnect_delay_max",
    "5",
    "-i",
    stream,
    "-analyzeduration",
    "0",
    "-loglevel",
    "0",
    "-f",
    `${typeof fmt === "string" ? fmt : "s16le"}`,
    "-ar",
    "48000",
    "-ac",
    "2"
  ];
}
__name(FFMPEG_ARGS_STRING, "FFMPEG_ARGS_STRING");
function FFMPEG_ARGS_PIPED(fmt) {
  return [
    "-analyzeduration",
    "0",
    "-loglevel",
    "0",
    "-f",
    `${typeof fmt === "string" ? fmt : "s16le"}`,
    "-ar",
    "48000",
    "-ac",
    "2"
  ];
}
__name(FFMPEG_ARGS_PIPED, "FFMPEG_ARGS_PIPED");
function createFFmpegStream(stream, options) {
  if (options?.skip && typeof stream !== "string")
    return stream;
  options ?? (options = {});
  const args = typeof stream === "string" ? FFMPEG_ARGS_STRING(stream, options.fmt) : FFMPEG_ARGS_PIPED(options.fmt);
  if (!Number.isNaN(options.seek))
    args.unshift("-ss", String(options.seek));
  if (Array.isArray(options.encoderArgs))
    args.push(...options.encoderArgs);
  const transcoder = new import_prism_media.FFmpeg({ shell: false, args });
  transcoder.on("close", () => transcoder.destroy());
  if (typeof stream !== "string") {
    stream.on("error", () => transcoder.destroy());
    stream.pipe(transcoder);
  }
  return transcoder;
}
__name(createFFmpegStream, "createFFmpegStream");

// src/Structures/Queue.ts
var import_os = __toESM(require("os"));
var import_worker_threads = require("worker_threads");
var import_utils2 = require("@discord-player/utils");

// src/utils/QueryResolver.ts
var import_youtube_sr = require("youtube-sr");
var import_soundcloud_scraper = require("soundcloud-scraper");
var spotifySongRegex = /^https?:\/\/(?:embed\.|open\.)(?:spotify\.com\/)(?:track\/|\?uri=spotify:track:)((\w|-){22})(\?si=.+)?$/;
var spotifyPlaylistRegex = /^https?:\/\/(?:embed\.|open\.)(?:spotify\.com\/)(?:playlist\/|\?uri=spotify:playlist:)((\w|-){22})(\?si=.+)?$/;
var spotifyAlbumRegex = /^https?:\/\/(?:embed\.|open\.)(?:spotify\.com\/)(?:album\/|\?uri=spotify:album:)((\w|-){22})(\?si=.+)?$/;
var vimeoRegex = /^(http|https)?:\/\/(www\.|player\.)?vimeo\.com\/(?:channels\/(?:\w+\/)?|groups\/([^/]*)\/videos\/|video\/|)(\d+)(?:|\/\?)$/;
var reverbnationRegex = /^https:\/\/(www.)?reverbnation.com\/(.+)\/song\/(.+)$/;
var attachmentRegex = /^https?:\/\/.+$/;
var appleMusicSongRegex = /^https?:\/\/music\.apple\.com\/.+?\/(song|album)\/.+?(\/.+?\?i=|\/)([0-9]+)$/;
var appleMusicPlaylistRegex = /^https?:\/\/music\.apple\.com\/.+?\/playlist\/.+\/pl\.[a-f0-9]+$/;
var appleMusicAlbumRegex = /^https?:\/\/music\.apple\.com\/.+?\/album\/.+\/([0-9]+)$/;
var QueryResolver = class {
  constructor() {
  }
  static get regex() {
    return {
      spotifyAlbumRegex,
      spotifyPlaylistRegex,
      spotifySongRegex,
      vimeoRegex,
      reverbnationRegex,
      attachmentRegex,
      appleMusicAlbumRegex,
      appleMusicPlaylistRegex,
      appleMusicSongRegex
    };
  }
  static resolve(query) {
    query = query.trim();
    if ((0, import_soundcloud_scraper.validateURL)(query, "track"))
      return QueryType.SOUNDCLOUD_TRACK;
    if ((0, import_soundcloud_scraper.validateURL)(query, "playlist") || query.includes("/sets/"))
      return QueryType.SOUNDCLOUD_PLAYLIST;
    if (import_youtube_sr.YouTube.isPlaylist(query))
      return QueryType.YOUTUBE_PLAYLIST;
    if (QueryResolver.validateId(query) || QueryResolver.validateURL(query))
      return QueryType.YOUTUBE_VIDEO;
    if (spotifySongRegex.test(query))
      return QueryType.SPOTIFY_SONG;
    if (spotifyPlaylistRegex.test(query))
      return QueryType.SPOTIFY_PLAYLIST;
    if (spotifyAlbumRegex.test(query))
      return QueryType.SPOTIFY_ALBUM;
    if (vimeoRegex.test(query))
      return QueryType.VIMEO;
    if (reverbnationRegex.test(query))
      return QueryType.REVERBNATION;
    if (appleMusicAlbumRegex.test(query))
      return QueryType.APPLE_MUSIC_ALBUM;
    if (appleMusicPlaylistRegex.test(query))
      return QueryType.APPLE_MUSIC_PLAYLIST;
    if (appleMusicSongRegex.test(query))
      return QueryType.APPLE_MUSIC_SONG;
    if (attachmentRegex.test(query))
      return QueryType.ARBITRARY;
    return QueryType.YOUTUBE_SEARCH;
  }
  static getVimeoID(query) {
    return QueryResolver.resolve(query) === QueryType.VIMEO ? query.split("/").filter((x) => !!x).pop() : null;
  }
  static validateId(q) {
    return import_youtube_sr.YouTube.Regex.VIDEO_ID.test(q);
  }
  static validateURL(q) {
    return import_youtube_sr.YouTube.Regex.VIDEO_URL.test(q);
  }
};
__name(QueryResolver, "QueryResolver");

// src/Structures/Queue.ts
var import_youtube_sr2 = require("youtube-sr");
var OBCS_DEFAULT = /* @__PURE__ */ __name(async () => {
  return void 0;
}, "OBCS_DEFAULT");
var _destroyed, _watchDestroyed, watchDestroyed_fn, _getBufferingTimeout, getBufferingTimeout_fn;
var Queue = class {
  constructor(player, guild, options = {}) {
    __privateAdd(this, _watchDestroyed);
    __privateAdd(this, _getBufferingTimeout);
    this.tracks = [];
    this.previousTracks = [];
    this.playing = false;
    this.metadata = null;
    this.repeatMode = 0;
    this.id = import_discord2.SnowflakeUtil.generate().toString();
    this._streamTime = 0;
    this._cooldownsTimeout = new import_utils2.Collection();
    this._activeFilters = [];
    this._filtersUpdate = false;
    this._lastEQBands = [];
    this._lastAudioFilters = [];
    __privateAdd(this, _destroyed, false);
    this.onBeforeCreateStream = OBCS_DEFAULT;
    this.player = player;
    this.guild = guild;
    this.options = {};
    Object.assign(
      this.options,
      {
        leaveOnEnd: true,
        leaveOnStop: true,
        leaveOnEmpty: true,
        leaveOnEndCooldown: 1e3,
        leaveOnEmptyCooldown: 1e3,
        autoSelfDeaf: true,
        ytdlOptions: {
          highWaterMark: 1 << 25
        },
        initialVolume: 100,
        bufferingTimeout: 3e3,
        spotifyBridge: true,
        disableVolume: false,
        disableEqualizer: false,
        equalizerBands: [],
        disableBiquad: false,
        disableFilters: false,
        defaultFilters: []
      },
      options
    );
    if (Array.isArray(options.equalizerBands))
      this._lastEQBands = options.equalizerBands;
    if (Array.isArray(options.defaultFilters))
      this._lastAudioFilters = options.defaultFilters;
    if (options.biquadFilter != null)
      this._lastBiquadFilter = options.biquadFilter;
    if ("onBeforeCreateStream" in this.options)
      this.onBeforeCreateStream = this.options.onBeforeCreateStream;
    this.player.emit("debug", this, `Queue initialized:

${this.player.scanDeps()}`);
  }
  isFiltersAvailable() {
    return this.connection.audioFilters != null;
  }
  get filters() {
    return this.connection.audioFilters;
  }
  isBiquadEnabled() {
    return this.connection.biquad != null;
  }
  isBiquadOff() {
    return this.isBiquadEnabled() && !this.connection.biquad.disabled;
  }
  toggleBiquad() {
    const eq = this.connection.biquad;
    if (!eq)
      return false;
    eq.toggle();
    return !eq.disabled;
  }
  enableBiquad() {
    const eq = this.connection.biquad;
    if (!eq)
      return false;
    eq.enable();
    return !eq.disabled;
  }
  disableBiquad() {
    const eq = this.connection.biquad;
    if (!eq)
      return false;
    eq.disable();
    return eq.disabled;
  }
  setBiquadFilter(filter) {
    if (!this.isBiquadEnabled())
      return;
    this.connection.biquad.setFilter(filter);
    this._lastBiquadFilter = filter;
  }
  getBiquadFilterName() {
    return this.connection.biquad?.getFilterName();
  }
  getBiquadFilter() {
    return this.connection.biquad?.filter;
  }
  setBiquadGain(gain) {
    return this.connection.biquad?.setGain(gain);
  }
  setBiquadCutoff(val) {
    return this.connection.biquad?.setCutoff(val);
  }
  setBiquadSampleRate(val) {
    return this.connection.biquad?.setSample(val);
  }
  setBiquadQ(val) {
    return this.connection.biquad?.setQ(val);
  }
  setEqualizer(bands) {
    if (!this.connection.equalizer)
      return false;
    if (!Array.isArray(bands) || !bands.length) {
      this.connection.equalizer.resetEQ();
      this._lastEQBands = this.getEqualizer();
    } else {
      this.connection.equalizer.setEQ(bands);
      this._lastEQBands = this.getEqualizer();
    }
    return true;
  }
  setEqualizerBand(band, gain) {
    if (!this.connection.equalizer)
      return null;
    this.connection.equalizer.equalizer.setGain(band, gain);
    this._lastEQBands = this.getEqualizer();
    return true;
  }
  getEqualizerBand(band) {
    if (!this.connection.equalizer)
      return null;
    return this.connection.equalizer.equalizer.getGain(band);
  }
  getEqualizer() {
    if (!this.connection.equalizer)
      return [];
    return this.connection.equalizer.getEQ();
  }
  isEqualizerEnabled() {
    return this.connection.equalizer != null;
  }
  isEqualizerOff() {
    return this.isEqualizerEnabled() && !this.connection.equalizer.disabled;
  }
  toggleEqualizer() {
    const eq = this.connection.equalizer;
    if (!eq)
      return false;
    eq.toggle();
    return !eq.disabled;
  }
  enableEqualizer() {
    const eq = this.connection.equalizer;
    if (!eq)
      return false;
    eq.enable();
    return !eq.disabled;
  }
  disableEqualizer() {
    const eq = this.connection.equalizer;
    if (!eq)
      return false;
    eq.disable();
    return eq.disabled;
  }
  async forceNext() {
    if (this.connection.audioResource) {
      this.connection.emit("finish", this.connection.audioResource);
    } else if (this.tracks.length) {
      await this.play();
    }
  }
  get current() {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    return this.connection.audioResource?.metadata ?? this.tracks[0];
  }
  get destroyed() {
    return __privateGet(this, _destroyed);
  }
  nowPlaying() {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    return this.current;
  }
  async connect(channel) {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    const _channel = this.guild.channels.resolve(channel);
    if (![import_discord2.ChannelType.GuildStageVoice, import_discord2.ChannelType.GuildVoice].includes(_channel?.type))
      throw new PlayerError(`Channel type must be GuildVoice or GuildStageVoice, got ${_channel?.type}!`, "InvalidArgType" /* INVALID_ARG_TYPE */);
    const connection = await this.player.voiceUtils.connect(_channel, {
      deaf: this.options.autoSelfDeaf
    });
    this.connection = connection;
    if (_channel.type === import_discord2.ChannelType.GuildStageVoice) {
      await _channel.guild.members.me.voice.setSuppressed(false).catch(async () => {
        return await _channel.guild.members.me.voice.setRequestToSpeak(true).catch(Util.noop);
      });
    }
    this.connection.on("audioFilters", (filters) => {
      this._lastAudioFilters = filters;
    });
    this.connection.on("error", (err) => {
      if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this, false))
        return;
      this.player.emit("connectionError", this, err);
    });
    this.connection.on("debug", (msg) => {
      if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this, false))
        return;
      this.player.emit("debug", this, msg);
    });
    this.player.emit("connectionCreate", this, this.connection);
    this.connection.on("start", (resource) => {
      if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this, false))
        return;
      this.playing = true;
      if (!this._filtersUpdate)
        this.player.emit("trackStart", this, resource?.metadata ?? this.current);
      this._filtersUpdate = false;
    });
    this.connection.on("finish", async (resource) => {
      if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this, false))
        return;
      this.playing = false;
      if (this._filtersUpdate)
        return;
      this._streamTime = 0;
      this.player.emit("trackEnd", this, resource.metadata);
      if (!this.tracks.length && this.repeatMode === 0 /* OFF */) {
        this.emitEnd();
      } else if (!this.tracks.length && this.repeatMode === 3 /* AUTOPLAY */) {
        this._handleAutoplay(Util.last(this.previousTracks));
      } else {
        if (this.repeatMode === 1 /* TRACK */)
          return void this.play(Util.last(this.previousTracks), { immediate: true });
        if (this.repeatMode === 2 /* QUEUE */)
          this.tracks.push(Util.last(this.previousTracks));
        const nextTrack = this.tracks.shift();
        this.play(nextTrack, { immediate: true });
        return;
      }
    });
    return this;
  }
  emitEnd() {
    const timeout = setTimeout(() => {
      if (!this.player.queues.has(this.guild.id))
        return;
      if (this.tracks.length || this.current)
        return;
      if (this.options.leaveOnEnd)
        this.destroy();
      this.player.emit("queueEnd", this);
    }, this.options.leaveOnEndCooldown || 0).unref();
    this._cooldownsTimeout.set(`queueEnd_${this.guild.id}`, timeout);
  }
  refreshEndCooldown() {
    const existingTimeout = this._cooldownsTimeout.get(`queueEnd_${this.guild.id}`);
    if (this.tracks.length || this.current) {
      clearTimeout(existingTimeout);
      this._cooldownsTimeout.delete(`queueEnd_${this.guild.id}`);
    }
  }
  destroy(disconnect = this.options.leaveOnStop) {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    if (this.connection)
      this.connection.end();
    if (disconnect)
      this.connection?.disconnect();
    this.player.queues.delete(this.guild.id);
    this.player.voiceUtils.cache.delete(this.guild.id);
    __privateSet(this, _destroyed, true);
  }
  skip() {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    if (!this.connection)
      return false;
    this._filtersUpdate = false;
    this.connection.end();
    return true;
  }
  addTrack(track) {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    if (!(track instanceof Track_default))
      throw new PlayerError("invalid track", "InvalidTrack" /* INVALID_TRACK */);
    this.tracks.push(track);
    this.refreshEndCooldown();
    this.player.emit("trackAdd", this, track);
  }
  addTracks(tracks) {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    if (!tracks.every((y) => y instanceof Track_default))
      throw new PlayerError("invalid track", "InvalidTrack" /* INVALID_TRACK */);
    this.tracks.push(...tracks);
    this.refreshEndCooldown();
    this.player.emit("tracksAdd", this, tracks);
  }
  setPaused(paused) {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return false;
    if (!this.connection)
      return false;
    return paused ? this.connection.pause(true) : this.connection.resume();
  }
  get paused() {
    return this.connection.paused;
  }
  set paused(val) {
    this.setPaused(val);
  }
  pause() {
    return this.setPaused(true);
  }
  resume() {
    return this.setPaused(false);
  }
  setBitrate(bitrate) {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    if (!this.connection?.audioResource?.encoder)
      return;
    if (bitrate === "auto")
      bitrate = this.connection.channel?.bitrate ?? 64e3;
    this.connection.audioResource.encoder.setBitrate(bitrate);
  }
  setVolume(amount) {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    if (!this.connection)
      return false;
    this.options.initialVolume = amount;
    return this.connection.setVolume(amount);
  }
  setRepeatMode(mode) {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    if (![0 /* OFF */, 2 /* QUEUE */, 1 /* TRACK */, 3 /* AUTOPLAY */].includes(mode))
      throw new PlayerError(`Unknown repeat mode "${mode}"!`, "UnknownRepeatMode" /* UNKNOWN_REPEAT_MODE */);
    if (mode === this.repeatMode)
      return false;
    this.repeatMode = mode;
    return true;
  }
  get volume() {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return 100;
    if (!this.connection)
      return 100;
    return this.connection.volume;
  }
  set volume(amount) {
    this.setVolume(amount);
  }
  get streamTime() {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return 0;
    if (!this.connection)
      return 0;
    const playbackTime = this._streamTime + this.connection.streamTime;
    const NC = this._activeFilters.includes("nightcore") ? 1.25 : null;
    const VW = this._activeFilters.includes("vaporwave") ? 0.8 : null;
    if (NC && VW)
      return playbackTime * (NC + VW);
    return NC ? playbackTime * NC : VW ? playbackTime * VW : playbackTime;
  }
  set streamTime(time) {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    this.seek(time);
  }
  getFiltersEnabled() {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    return AudioFilters_default.names.filter((x) => this._activeFilters.includes(x));
  }
  getFiltersDisabled() {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    return AudioFilters_default.names.filter((x) => !this._activeFilters.includes(x));
  }
  async setFilters(filters) {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    if (!filters || !Object.keys(filters).length) {
      const streamTime2 = this.streamTime;
      this._activeFilters = [];
      return await this.play(this.current, {
        immediate: true,
        filtersUpdate: true,
        seek: streamTime2,
        encoderArgs: []
      });
    }
    const _filters = [];
    for (const filter in filters) {
      if (filters[filter] === true)
        _filters.push(filter);
    }
    if (this._activeFilters.join("") === _filters.join(""))
      return;
    const newFilters = AudioFilters_default.create(_filters).trim();
    const streamTime = this.streamTime;
    this._activeFilters = _filters;
    return await this.play(this.current, {
      immediate: true,
      filtersUpdate: true,
      seek: streamTime,
      encoderArgs: !_filters.length ? void 0 : ["-af", newFilters]
    });
  }
  async seek(position) {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    if (!this.playing || !this.current)
      return false;
    if (position < 1)
      position = 0;
    if (position >= this.current.durationMS)
      return this.skip();
    await this.play(this.current, {
      immediate: true,
      filtersUpdate: true,
      seek: position
    });
    return true;
  }
  async back() {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    const prev = this.previousTracks[this.previousTracks.length - 2];
    if (!prev)
      throw new PlayerError("Could not find previous track", "TrackNotFound" /* TRACK_NOT_FOUND */);
    return await this.play(prev, { immediate: true });
  }
  clear() {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    this.tracks = [];
    this.previousTracks = [];
  }
  stop() {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    return this.destroy();
  }
  shuffle() {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    if (!this.tracks.length || this.tracks.length < 2)
      return false;
    for (let i = this.tracks.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [this.tracks[i], this.tracks[j]] = [this.tracks[j], this.tracks[i]];
    }
    return true;
  }
  remove(track) {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    let trackFound = null;
    if (typeof track === "number") {
      trackFound = this.tracks[track];
      if (trackFound) {
        this.tracks = this.tracks.filter((t) => t.id !== trackFound.id);
      }
    } else {
      trackFound = this.tracks.find((s) => s.id === (track instanceof Track_default ? track.id : track));
      if (trackFound) {
        this.tracks = this.tracks.filter((s) => s.id !== trackFound.id);
      }
    }
    return trackFound;
  }
  getTrackPosition(track) {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    if (typeof track === "number")
      return this.tracks[track] != null ? track : -1;
    return this.tracks.findIndex((pred) => pred.id === (track instanceof Track_default ? track.id : track));
  }
  jump(track) {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    const foundTrack = this.remove(track);
    if (!foundTrack)
      throw new PlayerError("Track not found", "TrackNotFound" /* TRACK_NOT_FOUND */);
    this.tracks.splice(0, 0, foundTrack);
    return void this.skip();
  }
  skipTo(track) {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    const trackIndex = this.getTrackPosition(track);
    const removedTrack = this.remove(track);
    if (!removedTrack)
      throw new PlayerError("Track not found", "TrackNotFound" /* TRACK_NOT_FOUND */);
    this.tracks.splice(0, trackIndex, removedTrack);
    return void this.skip();
  }
  insert(track, index = 0) {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    if (!track || !(track instanceof Track_default))
      throw new PlayerError("track must be the instance of Track", "InvalidTrack" /* INVALID_TRACK */);
    if (typeof index !== "number" || index < 0 || !Number.isFinite(index))
      throw new PlayerError(`Invalid index "${index}"`, "InvalidArgType" /* INVALID_ARG_TYPE */);
    this.tracks.splice(index, 0, track);
    this.player.emit("trackAdd", this, track);
  }
  getPlayerTimestamp() {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    const currentStreamTime = this.streamTime;
    const totalTime = this.current.durationMS;
    const currentTimecode = Util.buildTimeCode(Util.parseMS(currentStreamTime));
    const endTimecode = Util.buildTimeCode(Util.parseMS(totalTime));
    return {
      current: currentTimecode,
      end: endTimecode,
      progress: Math.round(currentStreamTime / totalTime * 100)
    };
  }
  createProgressBar(options = { timecodes: true }) {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    const length = typeof options.length === "number" ? options.length <= 0 || options.length === Infinity ? 15 : options.length : 15;
    const index = Math.round(this.streamTime / this.current.durationMS * length);
    const indicator = typeof options.indicator === "string" && options.indicator.length > 0 ? options.indicator : "\u{1F518}";
    const line = typeof options.line === "string" && options.line.length > 0 ? options.line : "\u25AC";
    if (index >= 1 && index <= length) {
      const bar = line.repeat(length - 1).split("");
      bar.splice(index, 0, indicator);
      if (options.timecodes) {
        const timestamp = this.getPlayerTimestamp();
        return `${timestamp.current} \u2503 ${bar.join("")} \u2503 ${timestamp.end}`;
      } else {
        return `${bar.join("")}`;
      }
    } else {
      if (options.timecodes) {
        const timestamp = this.getPlayerTimestamp();
        return `${timestamp.current} \u2503 ${indicator}${line.repeat(length - 1)} \u2503 ${timestamp.end}`;
      } else {
        return `${indicator}${line.repeat(length - 1)}`;
      }
    }
  }
  get totalTime() {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return 0;
    return this.tracks.length > 0 ? this.tracks.map((t) => t.durationMS).reduce((p, c) => p + c) : 0;
  }
  generateStatistics() {
    return {
      guild: this.guild.id,
      memory: process.memoryUsage(),
      tracks: this.tracks.length,
      os: {
        cpuCount: import_os.default.cpus().length,
        totalMem: import_os.default.totalmem(),
        freeMem: import_os.default.freemem(),
        platform: process.platform
      },
      isShard: typeof process.send === "function" || import_worker_threads.parentPort != null,
      latency: {
        client: this.player.client.ws.ping,
        udp: this.connection.voiceConnection.ping.udp,
        ws: this.connection.voiceConnection.ping.ws,
        eventLoop: this.player.eventLoopLag
      },
      subscribers: this.player.queues.size,
      connections: this.player.queues.filter((x) => x.connection?.voiceConnection != null).size,
      extractors: this.player.extractors.size
    };
  }
  get ping() {
    return this.connection.voiceConnection.ping.udp;
  }
  async play(src, options = {}) {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this, false))
      return;
    if (!this.connection || !this.connection.voiceConnection)
      throw new PlayerError("Voice connection is not available, use <Queue>.connect()!", "NoConnection" /* NO_CONNECTION */);
    if (src && (this.playing || this.tracks.length) && !options.immediate)
      return this.addTrack(src);
    const track = options.filtersUpdate && !options.immediate ? src || this.current : src ?? this.tracks.shift();
    if (!track)
      return;
    this.player.emit("debug", this, "Received play request");
    if (!options.filtersUpdate) {
      this.previousTracks = this.previousTracks.filter((x) => x.id !== track.id);
      this.previousTracks.push(track);
    }
    let stream = null;
    const hasCustomDownloader = typeof this.onBeforeCreateStream === "function";
    if (hasCustomDownloader) {
      const qt = track.queryType || (track.raw.source === "spotify" ? "spotifySong" : track.raw.source === "apple_music" ? "appleMusicSong" : track.raw.source) || "arbitrary";
      stream = await this.onBeforeCreateStream(track, qt, this) || null;
    }
    if (!stream) {
      const streamInfo = await this.player.extractors.run(async (extractor) => {
        const canStream = await extractor.validate(track.url, track.queryType || QueryResolver.resolve(track.url));
        if (!canStream)
          return false;
        return await extractor.stream(track);
      });
      if (!streamInfo || !streamInfo.result) {
        this.player.emit("error", this, new Error("No stream extractors are available for this track"));
        return void this.play(this.tracks.shift(), { immediate: true });
      }
      stream = streamInfo.result;
    }
    const ffmpegStream = createFFmpegStream(stream, {
      encoderArgs: options.encoderArgs || this._activeFilters.length ? ["-af", AudioFilters_default.create(this._activeFilters)] : [],
      seek: options.seek ? options.seek / 1e3 : 0,
      fmt: "s16le"
    }).on("error", (err) => {
      if (!`${err}`.toLowerCase().includes("premature close"))
        this.player.emit("error", this, err);
    });
    const resource = this.connection.createStream(ffmpegStream, {
      type: import_voice.StreamType.Raw,
      data: track,
      disableVolume: Boolean(this.options.disableVolume),
      disableEqualizer: Boolean(this.options.disableEqualizer),
      eq: this._lastEQBands,
      disableBiquad: Boolean(this.options.disableBiquad),
      biquadFilter: this._lastBiquadFilter,
      defaultFilters: this._lastAudioFilters,
      disableFilters: Boolean(this.options.disableFilters)
    });
    if (options.seek)
      this._streamTime = options.seek;
    this._filtersUpdate = options.filtersUpdate;
    const volumeTransformer = resource.volume;
    if (volumeTransformer && typeof this.options.initialVolume === "number")
      volumeTransformer.setVolume(Math.pow(this.options.initialVolume / 100, 1.660964));
    if (volumeTransformer?.hasSmoothness && typeof this.options.volumeSmoothness === "number") {
      if (typeof volumeTransformer.setSmoothness === "function")
        volumeTransformer.setSmoothness(this.options.volumeSmoothness || 0);
    }
    setTimeout(() => {
      this.connection.playStream(resource);
    }, __privateMethod(this, _getBufferingTimeout, getBufferingTimeout_fn).call(this)).unref();
  }
  async _handleAutoplay(track) {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    if (!track || ![track.source, track.raw?.source].includes("youtube")) {
      return this.emitEnd();
    }
    let info = await import_youtube_sr2.YouTube.getVideo(track.url).then((x) => x.videos[0]).catch(Util.noop);
    if (!info)
      info = await import_youtube_sr2.YouTube.search(track.author).then((x) => x[0]).catch(Util.noop);
    if (!info) {
      return this.emitEnd();
    }
    const nextTrack = new Track_default(this.player, {
      title: info.title,
      url: `https://www.youtube.com/watch?v=${info.id}`,
      duration: info.durationFormatted || Util.buildTimeCode(Util.parseMS(info.duration * 1e3)),
      description: "",
      thumbnail: typeof info.thumbnail === "string" ? info.thumbnail : info.thumbnail.url,
      views: info.views,
      author: info.channel.name,
      requestedBy: track.requestedBy,
      source: "youtube",
      queryType: "youtubeVideo"
    });
    this.play(nextTrack, { immediate: true });
  }
  *[Symbol.iterator]() {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    yield* this.tracks;
  }
  toJSON() {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    return {
      id: this.id,
      guild: this.guild.id,
      voiceChannel: this.connection?.channel?.id,
      options: this.options,
      tracks: this.tracks.map((m) => m.toJSON())
    };
  }
  toString() {
    if (__privateMethod(this, _watchDestroyed, watchDestroyed_fn).call(this))
      return;
    if (!this.tracks.length)
      return "No songs available to display!";
    return `**Upcoming Songs:**
${this.tracks.map((m, i) => `${i + 1}. **${m.title}**`).join("\n")}`;
  }
};
__name(Queue, "Queue");
_destroyed = new WeakMap();
_watchDestroyed = new WeakSet();
watchDestroyed_fn = /* @__PURE__ */ __name(function(emit = true) {
  if (__privateGet(this, _destroyed)) {
    if (emit)
      this.player.emit("error", this, new PlayerError("Cannot use destroyed queue", "DestroyedQueue" /* DESTROYED_QUEUE */));
    return true;
  }
  return false;
}, "#watchDestroyed");
_getBufferingTimeout = new WeakSet();
getBufferingTimeout_fn = /* @__PURE__ */ __name(function() {
  const timeout = this.options.bufferingTimeout;
  if (isNaN(timeout) || timeout < 0 || !Number.isFinite(timeout))
    return 1e3;
  return timeout;
}, "#getBufferingTimeout");

// src/VoiceInterface/VoiceUtils.ts
var import_voice3 = require("@discordjs/voice");

// src/VoiceInterface/StreamDispatcher.ts
var import_voice2 = require("@discordjs/voice");
var import_tiny_typed_emitter = require("tiny-typed-emitter");
var import_equalizer = require("@discord-player/equalizer");
var StreamDispatcher = class extends import_tiny_typed_emitter.TypedEmitter {
  constructor(connection, channel, connectionTimeout = 2e4) {
    super();
    this.connectionTimeout = connectionTimeout;
    this.readyLock = false;
    this.equalizer = null;
    this.biquad = null;
    this.audioFilters = null;
    this.voiceConnection = connection;
    this.audioPlayer = (0, import_voice2.createAudioPlayer)();
    this.channel = channel;
    this.voiceConnection.on("stateChange", async (_, newState) => {
      if (newState.status === import_voice2.VoiceConnectionStatus.Disconnected) {
        if (newState.reason === import_voice2.VoiceConnectionDisconnectReason.WebSocketClose && newState.closeCode === 4014) {
          try {
            await (0, import_voice2.entersState)(this.voiceConnection, import_voice2.VoiceConnectionStatus.Connecting, this.connectionTimeout);
          } catch {
            try {
              this.voiceConnection.destroy();
            } catch (err) {
              this.emit("error", err);
            }
          }
        } else if (this.voiceConnection.rejoinAttempts < 5) {
          await Util.wait((this.voiceConnection.rejoinAttempts + 1) * 5e3);
          this.voiceConnection.rejoin();
        } else {
          try {
            this.voiceConnection.destroy();
          } catch (err) {
            this.emit("error", err);
          }
        }
      } else if (newState.status === import_voice2.VoiceConnectionStatus.Destroyed) {
        this.end();
      } else if (!this.readyLock && (newState.status === import_voice2.VoiceConnectionStatus.Connecting || newState.status === import_voice2.VoiceConnectionStatus.Signalling)) {
        this.readyLock = true;
        try {
          await (0, import_voice2.entersState)(this.voiceConnection, import_voice2.VoiceConnectionStatus.Ready, this.connectionTimeout);
        } catch {
          if (this.voiceConnection.state.status !== import_voice2.VoiceConnectionStatus.Destroyed) {
            try {
              this.voiceConnection.destroy();
            } catch (err) {
              this.emit("error", err);
            }
          }
        } finally {
          this.readyLock = false;
        }
      }
    });
    this.audioPlayer.on("stateChange", (oldState, newState) => {
      if (newState.status === import_voice2.AudioPlayerStatus.Playing) {
        if (!this.paused)
          return void this.emit("start", this.audioResource);
      } else if (newState.status === import_voice2.AudioPlayerStatus.Idle && oldState.status !== import_voice2.AudioPlayerStatus.Idle) {
        if (!this.paused) {
          void this.emit("finish", this.audioResource);
          if (this.equalizer) {
            this.equalizer.destroy();
            this.equalizer = null;
          }
          if (this.biquad) {
            this.biquad.destroy();
            this.biquad = null;
          }
          if (this.audioFilters) {
            this.audioFilters.destroy();
            this.audioFilters = null;
          }
          this.audioResource = null;
        }
      }
    });
    this.audioPlayer.on("debug", (m) => void this.emit("debug", m));
    this.audioPlayer.on("error", (error) => void this.emit("error", error));
    this.voiceConnection.subscribe(this.audioPlayer);
  }
  get paused() {
    return this.audioPlayer.state.status === import_voice2.AudioPlayerStatus.Paused;
  }
  set paused(val) {
    val ? this.pause(true) : this.resume();
  }
  isPaused() {
    return this.paused || this.audioPlayer.state.status === import_voice2.AudioPlayerStatus.AutoPaused;
  }
  isBuffering() {
    return this.audioPlayer.state.status === import_voice2.AudioPlayerStatus.Buffering;
  }
  isPlaying() {
    return this.audioPlayer.state.status === import_voice2.AudioPlayerStatus.Playing;
  }
  isIdle() {
    return this.audioPlayer.state.status === import_voice2.AudioPlayerStatus.Idle;
  }
  createStream(src, ops) {
    if (!ops?.disableEqualizer) {
      this.equalizer = new import_equalizer.EqualizerStream({
        channels: 1,
        disabled: false,
        bandMultiplier: ops?.eq || []
      });
    }
    if (!ops?.disableBiquad) {
      this.biquad = new import_equalizer.BiquadStream({
        filter: ops?.biquadFilter
      });
    }
    if (!ops?.disableFilters) {
      this.audioFilters = new import_equalizer.AudioFilter({
        filters: ops?.defaultFilters
      });
      this.audioFilters.onUpdate = () => {
        if (this.audioFilters)
          this.emit("audioFilters", this.audioFilters.filters);
      };
    }
    let stream = this.equalizer && typeof src !== "string" ? src.pipe(this.equalizer) : src;
    if (this.biquad && typeof stream !== "string")
      stream = stream.pipe(this.biquad);
    if (this.audioFilters && typeof stream !== "string")
      stream = stream.pipe(this.audioFilters);
    this.audioResource = (0, import_voice2.createAudioResource)(stream, {
      inputType: ops?.type ?? import_voice2.StreamType.Arbitrary,
      metadata: ops?.data,
      inlineVolume: !ops?.disableVolume
    });
    return this.audioResource;
  }
  get status() {
    return this.audioPlayer.state.status;
  }
  disconnect() {
    try {
      this.audioPlayer.stop(true);
      this.voiceConnection.destroy();
    } catch {
    }
  }
  end() {
    this.audioPlayer.stop();
  }
  pause(interpolateSilence) {
    const success = this.audioPlayer.pause(interpolateSilence);
    return success;
  }
  resume() {
    const success = this.audioPlayer.unpause();
    return success;
  }
  async playStream(resource = this.audioResource) {
    if (!resource)
      throw new PlayerError("Audio resource is not available!", "NoAudioResource" /* NO_AUDIO_RESOURCE */);
    if (resource.ended) {
      return void this.emit("finish", resource);
    }
    if (!this.audioResource)
      this.audioResource = resource;
    if (this.voiceConnection.state.status !== import_voice2.VoiceConnectionStatus.Ready) {
      try {
        await (0, import_voice2.entersState)(this.voiceConnection, import_voice2.VoiceConnectionStatus.Ready, this.connectionTimeout);
      } catch (err) {
        return void this.emit("error", err);
      }
    }
    try {
      this.audioPlayer.play(resource);
    } catch (e) {
      this.emit("error", e);
    }
    return this;
  }
  setVolume(value) {
    if (!this.audioResource?.volume || isNaN(value) || value < 0 || value > Infinity)
      return false;
    this.audioResource.volume.setVolumeLogarithmic(value / 100);
    return true;
  }
  get volume() {
    if (!this.audioResource?.volume)
      return 100;
    const currentVol = this.audioResource.volume.volume;
    return Math.round(Math.pow(currentVol, 1 / 1.660964) * 100);
  }
  get streamTime() {
    if (!this.audioResource)
      return 0;
    return this.audioResource.playbackDuration;
  }
};
__name(StreamDispatcher, "StreamDispatcher");

// src/VoiceInterface/VoiceUtils.ts
var import_utils3 = require("@discord-player/utils");
var VoiceUtils = class {
  constructor() {
    this.cache = new import_utils3.Collection();
  }
  async connect(channel, options) {
    const conn = await this.join(channel, options);
    const sub = new StreamDispatcher(conn, channel, options?.maxTime);
    this.cache.set(channel.guild.id, sub);
    return sub;
  }
  async join(channel, options) {
    const conn = (0, import_voice3.joinVoiceChannel)({
      guildId: channel.guild.id,
      channelId: channel.id,
      adapterCreator: channel.guild.voiceAdapterCreator,
      selfDeaf: Boolean(options?.deaf)
    });
    return conn;
  }
  disconnect(connection) {
    if (connection instanceof StreamDispatcher)
      return connection.voiceConnection.destroy();
    return connection.destroy();
  }
  getConnection(guild) {
    return this.cache.get(guild);
  }
};
__name(VoiceUtils, "VoiceUtils");

// src/Player.ts
var import_voice4 = require("@discordjs/voice");
var import_utils4 = require("@discord-player/utils");

// src/Structures/SearchResult.ts
var SearchResult = class {
  constructor(player, _data) {
    this.player = player;
    this._data = _data;
  }
  get query() {
    return this._data.query;
  }
  get queryType() {
    return this._data.queryType || QueryType.AUTO;
  }
  get extractor() {
    return this._data.extractor || null;
  }
  get playlist() {
    return this._data.playlist;
  }
  get tracks() {
    return this._data.tracks || [];
  }
  get requestedBy() {
    return this._data.requestedBy || null;
  }
  async execute() {
    return this.player.search(this.query, {
      searchEngine: this.queryType,
      requestedBy: this.requestedBy
    });
  }
  isEmpty() {
    return !this.tracks.length;
  }
  hasPlaylist() {
    return this.playlist != null;
  }
  hasTracks() {
    return this.tracks.length > 0;
  }
  toJSON() {
    return {
      query: this.query,
      queryType: this.queryType,
      playlist: this.playlist?.toJSON(false) || null,
      tracks: this.tracks.map((m) => m.toJSON(true)),
      extractor: this.extractor?.identifier || null,
      requestedBy: this.requestedBy?.toJSON() || null
    };
  }
};
__name(SearchResult, "SearchResult");

// src/Player.ts
var _lastLatency;
var Player = class extends import_tiny_typed_emitter2.TypedEmitter {
  constructor(client, options = {}) {
    super();
    this.options = {
      autoRegisterExtractor: true,
      ytdlOptions: {
        highWaterMark: 1 << 25
      },
      connectionTimeout: 2e4,
      smoothVolume: true,
      lagMonitor: 3e4
    };
    this.queues = new import_utils4.Collection();
    this.voiceUtils = new VoiceUtils();
    this.requiredEvents = ["error", "connectionError"];
    this.extractors = new ExtractorExecutionContext(this);
    __privateAdd(this, _lastLatency, -1);
    this.client = client;
    if (this.client?.options?.intents && !new import_discord3.IntentsBitField(this.client?.options?.intents).has(import_discord3.IntentsBitField.Flags.GuildVoiceStates)) {
      throw new PlayerError('client is missing "GuildVoiceStates" intent');
    }
    this.options = Object.assign(this.options, options);
    this.client.on("voiceStateUpdate", this._handleVoiceState.bind(this));
    if (this.options?.autoRegisterExtractor) {
      let nv;
      if (nv = Util.require("@discord-player/extractor")) {
        ["YouTubeExtractor", "SoundCloudExtractor", "ReverbnationExtractor", "VimeoExtractor", "AttachmentExtractor"].forEach((ext) => void this.extractors.register(nv[ext]));
      }
    }
    if (typeof this.options.lagMonitor === "number" && this.options.lagMonitor > 0) {
      setInterval(() => {
        const start = performance.now();
        setTimeout(() => {
          __privateSet(this, _lastLatency, performance.now() - start);
        }, 0).unref();
      }, this.options.lagMonitor).unref();
    }
  }
  get eventLoopLag() {
    return __privateGet(this, _lastLatency);
  }
  generateStatistics() {
    return this.queues.map((m) => m.generateStatistics());
  }
  _handleVoiceState(oldState, newState) {
    const queue = this.getQueue(oldState.guild.id);
    if (!queue || !queue.connection)
      return;
    this.emit("voiceStateUpdate", queue, oldState, newState);
    if (oldState.channelId && !newState.channelId && newState.member.id === newState.guild.members.me.id) {
      try {
        queue.destroy();
      } catch {
      }
      return void this.emit("botDisconnect", queue);
    }
    if (!oldState.channelId && newState.channelId && newState.member.id === newState.guild.members.me.id) {
      if (newState.serverMute != null && oldState.serverMute !== newState.serverMute) {
        queue.setPaused(newState.serverMute);
      } else if (newState.channel?.type === import_discord3.ChannelType.GuildStageVoice && newState.suppress != null && oldState.suppress !== newState.suppress) {
        queue.setPaused(newState.suppress);
        if (newState.suppress) {
          newState.guild.members.me.voice.setRequestToSpeak(true).catch(Util.noop);
        }
      }
    }
    if (!newState.channelId && oldState.channelId === queue.connection.channel.id) {
      if (!Util.isVoiceEmpty(queue.connection.channel))
        return;
      const timeout = setTimeout(() => {
        if (!Util.isVoiceEmpty(queue.connection.channel))
          return;
        if (!this.queues.has(queue.guild.id))
          return;
        if (queue.options.leaveOnEmpty)
          queue.destroy(true);
        this.emit("channelEmpty", queue);
      }, queue.options.leaveOnEmptyCooldown || 0).unref();
      queue._cooldownsTimeout.set(`empty_${oldState.guild.id}`, timeout);
    }
    if (newState.channelId && newState.channelId === queue.connection.channel.id) {
      const emptyTimeout = queue._cooldownsTimeout.get(`empty_${oldState.guild.id}`);
      const channelEmpty = Util.isVoiceEmpty(queue.connection.channel);
      if (!channelEmpty && emptyTimeout) {
        clearTimeout(emptyTimeout);
        queue._cooldownsTimeout.delete(`empty_${oldState.guild.id}`);
      }
    }
    if (oldState.channelId && newState.channelId && oldState.channelId !== newState.channelId) {
      if (newState.member.id === newState.guild.members.me.id) {
        if (queue.connection && newState.member.id === newState.guild.members.me.id)
          queue.connection.channel = newState.channel;
        const emptyTimeout = queue._cooldownsTimeout.get(`empty_${oldState.guild.id}`);
        const channelEmpty = Util.isVoiceEmpty(queue.connection.channel);
        if (!channelEmpty && emptyTimeout) {
          clearTimeout(emptyTimeout);
          queue._cooldownsTimeout.delete(`empty_${oldState.guild.id}`);
        } else {
          const timeout = setTimeout(() => {
            if (queue.connection && !Util.isVoiceEmpty(queue.connection.channel))
              return;
            if (!this.queues.has(queue.guild.id))
              return;
            if (queue.options.leaveOnEmpty)
              queue.destroy(true);
            this.emit("channelEmpty", queue);
          }, queue.options.leaveOnEmptyCooldown || 0).unref();
          queue._cooldownsTimeout.set(`empty_${oldState.guild.id}`, timeout);
        }
      } else {
        if (newState.channelId !== queue.connection.channel.id) {
          if (!Util.isVoiceEmpty(queue.connection.channel))
            return;
          if (queue._cooldownsTimeout.has(`empty_${oldState.guild.id}`))
            return;
          const timeout = setTimeout(() => {
            if (!Util.isVoiceEmpty(queue.connection.channel))
              return;
            if (!this.queues.has(queue.guild.id))
              return;
            if (queue.options.leaveOnEmpty)
              queue.destroy(true);
            this.emit("channelEmpty", queue);
          }, queue.options.leaveOnEmptyCooldown || 0).unref();
          queue._cooldownsTimeout.set(`empty_${oldState.guild.id}`, timeout);
        } else {
          const emptyTimeout = queue._cooldownsTimeout.get(`empty_${oldState.guild.id}`);
          const channelEmpty = Util.isVoiceEmpty(queue.connection.channel);
          if (!channelEmpty && emptyTimeout) {
            clearTimeout(emptyTimeout);
            queue._cooldownsTimeout.delete(`empty_${oldState.guild.id}`);
          }
        }
      }
    }
  }
  createQueue(guild, queueInitOptions = {}) {
    guild = this.client.guilds.resolve(guild);
    if (!guild)
      throw new PlayerError("Unknown Guild", "UnknownGuild" /* UNKNOWN_GUILD */);
    if (this.queues.has(guild.id))
      return this.queues.get(guild.id);
    const _meta = queueInitOptions.metadata;
    delete queueInitOptions["metadata"];
    queueInitOptions.volumeSmoothness ?? (queueInitOptions.volumeSmoothness = this.options.smoothVolume ? 0.08 : 0);
    queueInitOptions.ytdlOptions ?? (queueInitOptions.ytdlOptions = this.options.ytdlOptions);
    const queue = new Queue(this, guild, queueInitOptions);
    queue.metadata = _meta;
    this.queues.set(guild.id, queue);
    return queue;
  }
  getQueue(guild) {
    guild = this.client.guilds.resolve(guild);
    if (!guild)
      throw new PlayerError("Unknown Guild", "UnknownGuild" /* UNKNOWN_GUILD */);
    return this.queues.get(guild.id);
  }
  deleteQueue(guild) {
    guild = this.client.guilds.resolve(guild);
    if (!guild)
      throw new PlayerError("Unknown Guild", "UnknownGuild" /* UNKNOWN_GUILD */);
    const prev = this.getQueue(guild);
    try {
      prev.destroy();
    } catch {
    }
    this.queues.delete(guild.id);
    return prev;
  }
  async search(query, options) {
    if (options.requestedBy != null)
      options.requestedBy = this.client.users.resolve(options.requestedBy);
    if (query instanceof Track_default)
      return new SearchResult(this, {
        playlist: query.playlist || null,
        tracks: [query],
        query: query.toString(),
        extractor: null,
        queryType: QueryType.AUTO,
        requestedBy: options.requestedBy
      });
    if (!options)
      throw new PlayerError("DiscordPlayer#search needs search options!", "InvalidArgType" /* INVALID_ARG_TYPE */);
    let extractor = null;
    options.searchEngine ?? (options.searchEngine = QueryType.AUTO);
    const queryType = options.searchEngine === QueryType.AUTO ? QueryResolver.resolve(query) : options.searchEngine;
    if (options.searchEngine.startsWith("ext:")) {
      extractor = this.extractors.get(options.searchEngine.substring(4));
      if (!extractor)
        return new SearchResult(this, { query, queryType });
    }
    if (!extractor) {
      extractor = (await this.extractors.run((ext) => ext.validate(query, queryType)))?.extractor || null;
    }
    if (!extractor) {
      return new SearchResult(this, { query, queryType });
    }
    const res = await extractor.handle(query, {
      type: queryType,
      requestedBy: options.requestedBy
    }).catch(() => null);
    if (res) {
      return new SearchResult(this, {
        query,
        queryType,
        playlist: res.playlist,
        tracks: res.tracks,
        extractor
      });
    }
    const result = await this.extractors.run(
      async (ext) => await ext.validate(query) && ext.handle(query, {
        type: queryType,
        requestedBy: options.requestedBy
      })
    );
    if (!result?.result)
      return new SearchResult(this, { query, queryType });
    return new SearchResult(this, {
      query,
      queryType,
      playlist: result.result.playlist,
      tracks: result.result.tracks,
      extractor: result.extractor
    });
  }
  scanDeps() {
    const line = "-".repeat(50);
    const depsReport = (0, import_voice4.generateDependencyReport)();
    const extractorReport = this.extractors.store.map((m) => {
      return m.identifier;
    }).join("\n");
    return `${depsReport}
${line}
Loaded Extractors:
${extractorReport || "None"}`;
  }
  emit(eventName, ...args) {
    if (this.requiredEvents.includes(eventName) && !super.eventNames().includes(eventName)) {
      console.error(...args);
      process.emitWarning(`[DiscordPlayerWarning] Unhandled "${eventName}" event! Events ${this.requiredEvents.map((m) => `"${m}"`).join(", ")} must have event listeners!`);
      return false;
    } else {
      return super.emit(eventName, ...args);
    }
  }
  resolveQueue(queueLike) {
    return this.getQueue(queueLike instanceof Queue ? queueLike.guild : queueLike);
  }
  *[Symbol.iterator]() {
    yield* Array.from(this.queues.values());
  }
  createPlaylist(data) {
    return new Playlist(this, data);
  }
};
__name(Player, "Player");
_lastLatency = new WeakMap();

// src/index.ts
var version = "5.4.1-dev.0";
if (!import_discord4.version.startsWith("14")) {
  process.emitWarning(`Discord.js v${import_discord4.version} is incompatible with Discord Player v${version}! Please use >=v14.x of Discord.js`);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AudioFilters,
  BaseExtractor,
  ErrorStatusCode,
  ExtractorExecutionContext,
  FFMPEG_ARGS_PIPED,
  FFMPEG_ARGS_STRING,
  Player,
  PlayerError,
  Playlist,
  QueryResolver,
  QueryType,
  Queue,
  QueueRepeatMode,
  StreamDispatcher,
  Track,
  Util,
  VoiceUtils,
  VolumeTransformer,
  createFFmpegStream,
  version
});
//# sourceMappingURL=index.js.map