{"version":3,"sources":["../src/index.ts","../src/VoiceInterface/VolumeTransformer.ts","../src/smoothVolume.ts","../src/utils/AudioFilters.ts","../src/extractors/BaseExtractor.ts","../src/extractors/ExtractorExecutionContext.ts","../src/Structures/Playlist.ts","../src/Player.ts","../src/Structures/Queue.ts","../src/Structures/Track.ts","../src/types/types.ts","../src/utils/Util.ts","../src/Structures/PlayerError.ts","../src/utils/FFmpegStream.ts","../src/utils/QueryResolver.ts","../src/VoiceInterface/VoiceUtils.ts","../src/VoiceInterface/StreamDispatcher.ts","../src/Structures/SearchResult.ts"],"sourcesContent":["// try applying smooth volume patch on load\nimport './smoothVolume';\nimport { version as djsVersion } from 'discord.js';\n\nexport { AudioFilters } from './utils/AudioFilters';\nexport * from './extractors/BaseExtractor';\nexport * from './extractors/ExtractorExecutionContext';\nexport { Playlist } from './Structures/Playlist';\nexport { Player } from './Player';\nexport { PlayerError, ErrorStatusCode } from './Structures/PlayerError';\nexport { QueryResolver } from './utils/QueryResolver';\nexport { Queue } from './Structures/Queue';\nexport { Track } from './Structures/Track';\nexport { VoiceUtils } from './VoiceInterface/VoiceUtils';\nexport { VoiceEvents, StreamDispatcher } from './VoiceInterface/StreamDispatcher';\nexport * from './VoiceInterface/VolumeTransformer';\nexport { Util } from './utils/Util';\nexport * from './types/types';\nexport * from './utils/FFmpegStream';\n\n// eslint-disable-next-line @typescript-eslint/no-inferrable-types\nexport const version: string = '5.4.1-dev.0';\n\nif (!djsVersion.startsWith('14')) {\n    process.emitWarning(`Discord.js v${djsVersion} is incompatible with Discord Player v${version}! Please use >=v14.x of Discord.js`);\n}\n","// prism's volume transformer with smooth volume support\n\nimport { Transform, TransformOptions } from 'stream';\n\nexport interface VolumeTransformerOptions extends TransformOptions {\n    type?: 's16le' | 's16be' | 's32le' | 's32be';\n    smoothness?: number;\n    volume?: number;\n}\n\nexport class VolumeTransformer extends Transform {\n    private _bits: number;\n    private _smoothing: number;\n    private _bytes: number;\n    private _extremum: number;\n    private _chunk: Buffer | null;\n    public volume: number;\n    private _targetVolume: number;\n    public type: 's16le' | 's32le' | 's16be' | 's32be';\n    constructor(options: VolumeTransformerOptions = {}) {\n        super(options);\n        switch (options.type) {\n            case 's16le':\n                this._readInt = (buffer, index) => buffer.readInt16LE(index);\n                this._writeInt = (buffer, int, index) => buffer.writeInt16LE(int, index);\n                this._bits = 16;\n                break;\n            case 's16be':\n                this._readInt = (buffer, index) => buffer.readInt16BE(index);\n                this._writeInt = (buffer, int, index) => buffer.writeInt16BE(int, index);\n                this._bits = 16;\n                break;\n            case 's32le':\n                this._readInt = (buffer, index) => buffer.readInt32LE(index);\n                this._writeInt = (buffer, int, index) => buffer.writeInt32LE(int, index);\n                this._bits = 32;\n                break;\n            case 's32be':\n                this._readInt = (buffer, index) => buffer.readInt32BE(index);\n                this._writeInt = (buffer, int, index) => buffer.writeInt32BE(int, index);\n                this._bits = 32;\n                break;\n            default:\n                throw new Error('VolumeTransformer type should be one of s16le, s16be, s32le, s32be');\n        }\n        this.type = options.type;\n        this._bytes = this._bits / 8;\n        this._extremum = Math.pow(2, this._bits - 1);\n        this.volume = Number.isNaN(options.volume) ? 1 : Number(options.volume);\n        if (!Number.isFinite(this.volume)) this.volume = 1;\n        this._targetVolume = this.volume;\n        this._chunk = Buffer.alloc(0);\n        this._smoothing = options.smoothness || 0;\n    }\n\n    _readInt(buffer: Buffer, index: number) {\n        return index;\n    }\n    _writeInt(buffer: Buffer, int: number, index: number) {\n        return index;\n    }\n\n    _applySmoothness() {\n        if (this.volume < this._targetVolume) {\n            this.volume = this.volume + this._smoothing >= this._targetVolume ? this._targetVolume : this.volume + this._smoothing;\n        } else if (this.volume > this._targetVolume) {\n            this.volume = this.volume - this._smoothing <= this._targetVolume ? this._targetVolume : this.volume - this._smoothing;\n        }\n    }\n\n    _transform(chunk: Buffer, encoding: BufferEncoding, done: () => unknown) {\n        if (this.smoothingEnabled() && this.volume !== this._targetVolume) this._applySmoothness();\n\n        if (this.volume === 1) {\n            this.push(chunk);\n            return done();\n        }\n\n        const { _bytes, _extremum } = this;\n\n        chunk = this._chunk = Buffer.concat([this._chunk!, chunk]);\n        if (chunk.length < _bytes) return done();\n\n        const complete = Math.floor(chunk.length / _bytes) * _bytes;\n\n        for (let i = 0; i < complete; i += _bytes) {\n            const int = Math.min(_extremum - 1, Math.max(-_extremum, Math.floor(this.volume * this._readInt(chunk, i))));\n            this._writeInt(chunk, int, i);\n        }\n\n        this._chunk = chunk.slice(complete);\n        this.push(chunk.slice(0, complete));\n        return done();\n    }\n\n    _destroy(err: Error, cb: (error: Error | null) => void) {\n        super._destroy(err, cb);\n        this._chunk = null;\n    }\n\n    setVolume(volume: number) {\n        if (Number.isNaN(volume)) volume = 1;\n        if (typeof volume !== 'number') volume = Number(volume);\n        if (!Number.isFinite(volume)) volume = volume < 0 ? 0 : 1;\n        this._targetVolume = volume;\n        if (this._smoothing <= 0) this.volume = volume;\n    }\n\n    setVolumeDecibels(db: number) {\n        this.setVolume(Math.pow(10, db / 20));\n    }\n\n    setVolumeLogarithmic(value: number) {\n        this.setVolume(Math.pow(value, 1.660964));\n    }\n\n    get volumeDecibels() {\n        return Math.log10(this.volume) * 20;\n    }\n\n    get volumeLogarithmic() {\n        return Math.pow(this.volume, 1 / 1.660964);\n    }\n\n    get smoothness() {\n        return this._smoothing;\n    }\n\n    setSmoothness(smoothness: number) {\n        this._smoothing = smoothness;\n    }\n\n    smoothingEnabled() {\n        return typeof this._smoothing === 'number' && !Number.isNaN(this._smoothing) && Number.isFinite(this._smoothing) && this._smoothing > 0;\n    }\n\n    get hasSmoothness() {\n        return true;\n    }\n\n    static get hasSmoothing() {\n        return true;\n    }\n}\n","import { VolumeTransformer as VolumeTransformerMock } from './VoiceInterface/VolumeTransformer';\n\nif (!('DISABLE_DISCORD_PLAYER_SMOOTH_VOLUME' in process.env)) {\n    try {\n        // eslint-disable-next-line\n        const mod = require('prism-media') as typeof import('prism-media') & { VolumeTransformer: typeof VolumeTransformerMock };\n\n        if (typeof mod.VolumeTransformer.hasSmoothing !== 'boolean') {\n            Reflect.set(mod, 'VolumeTransformer', VolumeTransformerMock);\n        }\n    } catch {\n        /* do nothing */\n    }\n}\n","import { FiltersName } from '../types/types';\n\nconst bass = (g: number) => `bass=g=${g}:f=110:w=0.3`;\n\nclass AudioFilters {\n    public constructor() {\n        return AudioFilters;\n    }\n\n    public static filters: Record<FiltersName, string> = {\n        bassboost_low: bass(15),\n        bassboost: bass(20),\n        bassboost_high: bass(30),\n        '8D': 'apulsator=hz=0.09',\n        vaporwave: 'aresample=48000,asetrate=48000*0.8',\n        nightcore: 'aresample=48000,asetrate=48000*1.25',\n        phaser: 'aphaser=in_gain=0.4',\n        tremolo: 'tremolo',\n        vibrato: 'vibrato=f=6.5',\n        reverse: 'areverse',\n        treble: 'treble=g=5',\n        normalizer2: 'dynaudnorm=g=101',\n        normalizer: 'acompressor',\n        surrounding: 'surround',\n        pulsator: 'apulsator=hz=1',\n        subboost: 'asubboost',\n        karaoke: 'stereotools=mlev=0.03',\n        flanger: 'flanger',\n        gate: 'agate',\n        haas: 'haas',\n        mcompand: 'mcompand',\n        mono: 'pan=mono|c0=.5*c0+.5*c1',\n        mstlr: 'stereotools=mode=ms>lr',\n        mstrr: 'stereotools=mode=ms>rr',\n        compressor: 'compand=points=-80/-105|-62/-80|-15.4/-15.4|0/-12|20/-7.6',\n        expander: 'compand=attacks=0:points=-80/-169|-54/-80|-49.5/-64.6|-41.1/-41.1|-25.8/-15|-10.8/-4.5|0/0|20/8.3',\n        softlimiter: 'compand=attacks=0:points=-80/-80|-12.4/-12.4|-6/-8|0/-6.8|20/-2.8',\n        chorus: 'chorus=0.7:0.9:55:0.4:0.25:2',\n        chorus2d: 'chorus=0.6:0.9:50|60:0.4|0.32:0.25|0.4:2|1.3',\n        chorus3d: 'chorus=0.5:0.9:50|60|40:0.4|0.32|0.3:0.25|0.4|0.3:2|2.3|1.3',\n        fadein: 'afade=t=in:ss=0:d=10',\n        dim: `afftfilt=\"'real=re * (1-clip((b/nb)*b,0,1))':imag='im * (1-clip((b/nb)*b,0,1))'\"`,\n        earrape: 'channelsplit,sidechaingate=level_in=64'\n    };\n\n    public static get<K extends FiltersName>(name: K) {\n        return this.filters[name];\n    }\n\n    public static has<K extends FiltersName>(name: K) {\n        return name in this.filters;\n    }\n\n    public static *[Symbol.iterator](): IterableIterator<{ name: FiltersName; value: string }> {\n        for (const [k, v] of Object.entries(this.filters)) {\n            yield { name: k as FiltersName, value: v as string };\n        }\n    }\n\n    public static get names() {\n        return Object.keys(this.filters) as FiltersName[];\n    }\n\n    // @ts-expect-error AudioFilters.length\n    public static get length() {\n        return this.names.length;\n    }\n\n    public static toString() {\n        return this.names.map((m) => (this as any)[m]).join(','); // eslint-disable-line @typescript-eslint/no-explicit-any\n    }\n\n    /**\n     * Create ffmpeg args from the specified filters name\n     * @param filter The filter name\n     * @returns\n     */\n    public static create<K extends FiltersName>(filters?: K[]) {\n        if (!filters || !Array.isArray(filters)) return this.toString();\n        return filters\n            .filter((predicate) => typeof predicate === 'string')\n            .map((m) => this.get(m))\n            .join(',');\n    }\n\n    /**\n     * Defines audio filter\n     * @param filterName The name of the filter\n     * @param value The ffmpeg args\n     */\n    public static define(filterName: string, value: string) {\n        this.filters[filterName as FiltersName] = value;\n    }\n\n    /**\n     * Defines multiple audio filters\n     * @param filtersArray Array of filters containing the filter name and ffmpeg args\n     */\n    public static defineBulk(filtersArray: { name: string; value: string }[]) {\n        filtersArray.forEach((arr) => this.define(arr.name, arr.value));\n    }\n}\n\nexport default AudioFilters;\nexport { AudioFilters };\n","import { User } from 'discord.js';\nimport { Readable } from 'stream';\nimport { Playlist } from '../Structures/Playlist';\nimport Track from '../Structures/Track';\nimport { PlayerEvents, SearchQueryType } from '../types/types';\nimport { ExtractorExecutionContext } from './ExtractorExecutionContext';\n\nexport class BaseExtractor {\n    /**\n     * Identifier for this extractor\n     */\n    public static identifier = 'com.discord-player.extractor';\n\n    /**\n     * Extractor constructor\n     * @param context Context that instantiated this extractor\n     */\n    public constructor(public context: ExtractorExecutionContext) {}\n\n    /**\n     * Identifier of this extractor\n     */\n    public get identifier() {\n        return (this.constructor as typeof BaseExtractor).identifier;\n    }\n\n    /**\n     * This method will be executed when this extractor is activated\n     */\n    public async activate() {\n        // executed when this extractor is activated\n        return;\n    }\n\n    /**\n     * This method will be executed when this extractor is deactivated\n     */\n    public async deactivate() {\n        // executed when this extractor is deactivated\n        return;\n    }\n\n    /**\n     * Validate incoming query\n     * @param query The query to validate\n     */\n    public async validate(query: string, type?: SearchQueryType | null): Promise<boolean> {\n        void type;\n        return false;\n    }\n\n    /**\n     * Stream the given track\n     * @param info The track to stream\n     */\n    public async stream(info: Track): Promise<Readable | string> {\n        void info;\n        throw new Error('Not Implemented');\n    }\n\n    /**\n     * Handle the given query\n     * @param query The query to handle\n     */\n    public async handle(query: string, context: ExtractorSearchContext): Promise<ExtractorInfo> {\n        void context;\n        throw new Error('Not Implemented');\n    }\n\n    /**\n     * A stream middleware to handle streams before passing it to the player\n     * @param stream The incoming stream\n     * @param next The next function\n     */\n    public handlePostStream(stream: Readable, next: NextFunction) {\n        return next(null, stream);\n    }\n\n    /**\n     * Dispatch an event to the player\n     * @param event The event to dispatch\n     * @param args The data to dispatch\n     */\n    public emit<K extends keyof PlayerEvents>(event: K, ...args: Parameters<PlayerEvents[K]>) {\n        return this.context.player.emit(event, ...args);\n    }\n}\n\nexport type NextFunction = (error?: Error | null, stream?: Readable) => void;\n\nexport interface ExtractorInfo {\n    playlist: Playlist | null;\n    tracks: Track[];\n}\n\nexport interface ExtractorSearchContext {\n    type?: SearchQueryType | null;\n    requestedBy?: User | null;\n}\n","import { Player } from '../Player';\nimport { Collection } from '@discord-player/utils';\nimport { BaseExtractor } from './BaseExtractor';\n\nexport class ExtractorExecutionContext {\n    public store = new Collection<string, BaseExtractor>();\n    public constructor(public player: Player) {}\n\n    public isRegistered(identifier: string) {\n        return this.store.has(identifier);\n    }\n\n    public get size() {\n        return this.store.size;\n    }\n\n    public get(identifier: string) {\n        return this.store.get(identifier);\n    }\n\n    public async register(_extractor: typeof BaseExtractor) {\n        if (typeof _extractor.identifier !== 'string' || this.store.has(_extractor.identifier)) return;\n        const extractor = new _extractor(this);\n\n        try {\n            this.store.set(_extractor.identifier, extractor);\n            await extractor.activate();\n        } catch {\n            this.store.delete(_extractor.identifier);\n        }\n    }\n\n    public async unregister<K extends string | BaseExtractor>(_extractor: K) {\n        const extractor = typeof _extractor === 'string' ? this.store.get(_extractor) : this.store.find((r) => r === _extractor);\n        if (!extractor) return;\n\n        try {\n            const key = extractor.identifier || this.store.findKey((e) => e === extractor)!;\n            this.store.delete(key);\n            await extractor.deactivate();\n        } catch {\n            // do nothing\n        }\n    }\n\n    public async unregisterAll() {\n        try {\n            await Promise.all(\n                this.store.map((e, k) => {\n                    this.store.delete(k);\n                    return e.deactivate();\n                })\n            );\n        } catch {\n            // do nothing\n        }\n    }\n\n    public async run<T = unknown>(fn: ExtractorExecutionFN<T>) {\n        for (const ext of this.store.values()) {\n            const result = await fn(ext).catch(() => {\n                return false;\n            });\n            if (result)\n                return {\n                    extractor: ext,\n                    result\n                } as ExtractorExecutionResult<T>;\n        }\n\n        return null;\n    }\n}\n\nexport interface ExtractorExecutionResult<T = unknown> {\n    extractor: BaseExtractor;\n    result: T;\n}\nexport type ExtractorExecutionFN<T = unknown> = (extractor: BaseExtractor) => Promise<T | boolean>;\n","import { Player } from '../Player';\nimport { Track } from './Track';\nimport { PlaylistInitData, PlaylistJSON, TrackJSON, TrackSource } from '../types/types';\n\nclass Playlist {\n    public readonly player: Player;\n    public tracks: Track[];\n    public title: string;\n    public description: string;\n    public thumbnail: string;\n    public type: 'album' | 'playlist';\n    public source: TrackSource;\n    public author: {\n        name: string;\n        url: string;\n    };\n    public id: string;\n    public url: string;\n    public readonly rawPlaylist?: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n    /**\n     * Playlist constructor\n     * @param {Player} player The player\n     * @param {PlaylistInitData} data The data\n     */\n    constructor(player: Player, data: PlaylistInitData) {\n        /**\n         * The player\n         * @name Playlist#player\n         * @type {Player}\n         * @readonly\n         */\n        this.player = player;\n\n        /**\n         * The tracks in this playlist\n         * @name Playlist#tracks\n         * @type {Track[]}\n         */\n        this.tracks = data.tracks ?? [];\n\n        /**\n         * The author of this playlist\n         * @name Playlist#author\n         * @type {object}\n         */\n        this.author = data.author;\n\n        /**\n         * The description\n         * @name Playlist#description\n         * @type {string}\n         */\n        this.description = data.description;\n\n        /**\n         * The thumbnail of this playlist\n         * @name Playlist#thumbnail\n         * @type {string}\n         */\n        this.thumbnail = data.thumbnail;\n\n        /**\n         * The playlist type:\n         * - `album`\n         * - `playlist`\n         * @name Playlist#type\n         * @type {string}\n         */\n        this.type = data.type;\n\n        /**\n         * The source of this playlist:\n         * - `youtube`\n         * - `soundcloud`\n         * - `spotify`\n         * - `arbitrary`\n         * @name Playlist#source\n         * @type {string}\n         */\n        this.source = data.source;\n\n        /**\n         * The playlist id\n         * @name Playlist#id\n         * @type {string}\n         */\n        this.id = data.id;\n\n        /**\n         * The playlist url\n         * @name Playlist#url\n         * @type {string}\n         */\n        this.url = data.url;\n\n        /**\n         * The playlist title\n         * @type {string}\n         */\n        this.title = data.title;\n\n        /**\n         * @name Playlist#rawPlaylist\n         * @type {any}\n         * @readonly\n         */\n    }\n\n    *[Symbol.iterator]() {\n        yield* this.tracks;\n    }\n\n    /**\n     * JSON representation of this playlist\n     * @param {boolean} [withTracks=true] If it should build json with tracks\n     * @returns {PlaylistJSON}\n     */\n    toJSON(withTracks = true) {\n        const payload = {\n            id: this.id,\n            url: this.url,\n            title: this.title,\n            description: this.description,\n            thumbnail: this.thumbnail,\n            type: this.type,\n            source: this.source,\n            author: this.author,\n            tracks: [] as TrackJSON[]\n        };\n\n        if (withTracks) payload.tracks = this.tracks.map((m) => m.toJSON(true));\n\n        return payload as PlaylistJSON;\n    }\n}\n\nexport { Playlist };\n","import { Client, GuildResolvable, Snowflake, VoiceState, IntentsBitField, User, ChannelType } from 'discord.js';\nimport { TypedEmitter as EventEmitter } from 'tiny-typed-emitter';\nimport { Queue } from './Structures/Queue';\nimport { VoiceUtils } from './VoiceInterface/VoiceUtils';\nimport { PlayerEvents, PlayerOptions, QueryType, SearchOptions, PlayerInitOptions, PlaylistInitData, SearchQueryType } from './types/types';\nimport Track from './Structures/Track';\nimport { QueryResolver } from './utils/QueryResolver';\nimport { Util } from './utils/Util';\nimport { PlayerError, ErrorStatusCode } from './Structures/PlayerError';\nimport { Playlist } from './Structures/Playlist';\nimport { generateDependencyReport } from '@discordjs/voice';\nimport { ExtractorExecutionContext } from './extractors/ExtractorExecutionContext';\nimport { Collection } from '@discord-player/utils';\nimport { BaseExtractor } from './extractors/BaseExtractor';\nimport { SearchResult } from './Structures/SearchResult';\n\nclass Player extends EventEmitter<PlayerEvents> {\n    public readonly client: Client;\n    public readonly options: PlayerInitOptions = {\n        autoRegisterExtractor: true,\n        ytdlOptions: {\n            highWaterMark: 1 << 25\n        },\n        connectionTimeout: 20000,\n        smoothVolume: true,\n        lagMonitor: 30000\n    };\n    public readonly queues = new Collection<Snowflake, Queue>();\n    public readonly voiceUtils = new VoiceUtils();\n    public requiredEvents = ['error', 'connectionError'] as string[];\n    public extractors = new ExtractorExecutionContext(this);\n    #lastLatency = -1;\n\n    /**\n     * Creates new Discord Player\n     * @param {Client} client The Discord Client\n     * @param {PlayerInitOptions} [options] The player init options\n     */\n    constructor(client: Client, options: PlayerInitOptions = {}) {\n        super();\n\n        /**\n         * The discord.js client\n         * @type {Client}\n         */\n        this.client = client;\n\n        if (this.client?.options?.intents && !new IntentsBitField(this.client?.options?.intents).has(IntentsBitField.Flags.GuildVoiceStates)) {\n            throw new PlayerError('client is missing \"GuildVoiceStates\" intent');\n        }\n\n        /**\n         * The extractors collection\n         * @type {ExtractorModel}\n         */\n        this.options = Object.assign(this.options, options);\n\n        this.client.on('voiceStateUpdate', this._handleVoiceState.bind(this));\n\n        if (this.options?.autoRegisterExtractor) {\n            let nv: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n            if ((nv = Util.require('@discord-player/extractor'))) {\n                ['YouTubeExtractor', 'SoundCloudExtractor', 'ReverbnationExtractor', 'VimeoExtractor', 'AttachmentExtractor'].forEach((ext) => void this.extractors.register(nv[ext]));\n            }\n        }\n\n        if (typeof this.options.lagMonitor === 'number' && this.options.lagMonitor > 0) {\n            setInterval(() => {\n                const start = performance.now();\n                setTimeout(() => {\n                    this.#lastLatency = performance.now() - start;\n                }, 0).unref();\n            }, this.options.lagMonitor).unref();\n        }\n    }\n\n    /**\n     * Event loop lag\n     * @type {number}\n     */\n    get eventLoopLag() {\n        return this.#lastLatency;\n    }\n\n    /**\n     * Generates statistics\n     */\n    generateStatistics() {\n        return this.queues.map((m) => m.generateStatistics());\n    }\n\n    /**\n     * Handles voice state update\n     * @param {VoiceState} oldState The old voice state\n     * @param {VoiceState} newState The new voice state\n     * @returns {void}\n     * @private\n     */\n    private _handleVoiceState(oldState: VoiceState, newState: VoiceState): void {\n        const queue = this.getQueue(oldState.guild.id);\n        if (!queue || !queue.connection) return;\n\n        this.emit('voiceStateUpdate', queue, oldState, newState);\n\n        if (oldState.channelId && !newState.channelId && newState.member!.id === newState.guild.members.me!.id) {\n            try {\n                queue.destroy();\n            } catch {\n                /* noop */\n            }\n            return void this.emit('botDisconnect', queue);\n        }\n\n        if (!oldState.channelId && newState.channelId && newState.member!.id === newState.guild.members.me!.id) {\n            if (newState.serverMute != null && oldState.serverMute !== newState.serverMute) {\n                queue.setPaused(newState.serverMute);\n            } else if (newState.channel?.type === ChannelType.GuildStageVoice && newState.suppress != null && oldState.suppress !== newState.suppress) {\n                queue.setPaused(newState.suppress);\n                if (newState.suppress) {\n                    newState.guild.members.me!.voice.setRequestToSpeak(true).catch(Util.noop);\n                }\n            }\n        }\n\n        if (!newState.channelId && oldState.channelId === queue.connection.channel.id) {\n            if (!Util.isVoiceEmpty(queue.connection.channel)) return;\n            const timeout = setTimeout(() => {\n                if (!Util.isVoiceEmpty(queue.connection.channel)) return;\n                if (!this.queues.has(queue.guild.id)) return;\n                if (queue.options.leaveOnEmpty) queue.destroy(true);\n                this.emit('channelEmpty', queue);\n            }, queue.options.leaveOnEmptyCooldown || 0).unref();\n            queue._cooldownsTimeout.set(`empty_${oldState.guild.id}`, timeout);\n        }\n\n        if (newState.channelId && newState.channelId === queue.connection.channel.id) {\n            const emptyTimeout = queue._cooldownsTimeout.get(`empty_${oldState.guild.id}`);\n            const channelEmpty = Util.isVoiceEmpty(queue.connection.channel);\n            if (!channelEmpty && emptyTimeout) {\n                clearTimeout(emptyTimeout);\n                queue._cooldownsTimeout.delete(`empty_${oldState.guild.id}`);\n            }\n        }\n\n        if (oldState.channelId && newState.channelId && oldState.channelId !== newState.channelId) {\n            if (newState.member!.id === newState.guild.members.me!.id) {\n                if (queue.connection && newState.member!.id === newState.guild.members.me!.id) queue.connection.channel = newState.channel!;\n                const emptyTimeout = queue._cooldownsTimeout.get(`empty_${oldState.guild.id}`);\n                const channelEmpty = Util.isVoiceEmpty(queue.connection.channel);\n                if (!channelEmpty && emptyTimeout) {\n                    clearTimeout(emptyTimeout);\n                    queue._cooldownsTimeout.delete(`empty_${oldState.guild.id}`);\n                } else {\n                    const timeout = setTimeout(() => {\n                        if (queue.connection && !Util.isVoiceEmpty(queue.connection.channel)) return;\n                        if (!this.queues.has(queue.guild.id)) return;\n                        if (queue.options.leaveOnEmpty) queue.destroy(true);\n                        this.emit('channelEmpty', queue);\n                    }, queue.options.leaveOnEmptyCooldown || 0).unref();\n                    queue._cooldownsTimeout.set(`empty_${oldState.guild.id}`, timeout);\n                }\n            } else {\n                if (newState.channelId !== queue.connection.channel.id) {\n                    if (!Util.isVoiceEmpty(queue.connection.channel)) return;\n                    if (queue._cooldownsTimeout.has(`empty_${oldState.guild.id}`)) return;\n                    const timeout = setTimeout(() => {\n                        if (!Util.isVoiceEmpty(queue.connection.channel)) return;\n                        if (!this.queues.has(queue.guild.id)) return;\n                        if (queue.options.leaveOnEmpty) queue.destroy(true);\n                        this.emit('channelEmpty', queue);\n                    }, queue.options.leaveOnEmptyCooldown || 0).unref();\n                    queue._cooldownsTimeout.set(`empty_${oldState.guild.id}`, timeout);\n                } else {\n                    const emptyTimeout = queue._cooldownsTimeout.get(`empty_${oldState.guild.id}`);\n                    const channelEmpty = Util.isVoiceEmpty(queue.connection.channel);\n                    if (!channelEmpty && emptyTimeout) {\n                        clearTimeout(emptyTimeout);\n                        queue._cooldownsTimeout.delete(`empty_${oldState.guild.id}`);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Creates a queue for a guild if not available, else returns existing queue\n     * @param {GuildResolvable} guild The guild\n     * @param {PlayerOptions} queueInitOptions Queue init options\n     * @returns {Queue}\n     */\n    createQueue<T = unknown>(guild: GuildResolvable, queueInitOptions: PlayerOptions & { metadata?: T } = {}): Queue<T> {\n        guild = this.client.guilds.resolve(guild)!;\n        if (!guild) throw new PlayerError('Unknown Guild', ErrorStatusCode.UNKNOWN_GUILD);\n        if (this.queues.has(guild.id)) return this.queues.get(guild.id) as Queue<T>;\n\n        const _meta = queueInitOptions.metadata;\n        delete queueInitOptions['metadata'];\n        queueInitOptions.volumeSmoothness ??= this.options.smoothVolume ? 0.08 : 0;\n        queueInitOptions.ytdlOptions ??= this.options.ytdlOptions;\n        const queue = new Queue(this, guild, queueInitOptions);\n        queue.metadata = _meta;\n        this.queues.set(guild.id, queue);\n\n        return queue as Queue<T>;\n    }\n\n    /**\n     * Returns the queue if available\n     * @param {GuildResolvable} guild The guild id\n     * @returns {Queue | undefined}\n     */\n    getQueue<T = unknown>(guild: GuildResolvable): Queue<T> | undefined {\n        guild = this.client.guilds.resolve(guild)!;\n        if (!guild) throw new PlayerError('Unknown Guild', ErrorStatusCode.UNKNOWN_GUILD);\n        return this.queues.get(guild.id) as Queue<T>;\n    }\n\n    /**\n     * Deletes a queue and returns deleted queue object\n     * @param {GuildResolvable} guild The guild id to remove\n     * @returns {Queue}\n     */\n    deleteQueue<T = unknown>(guild: GuildResolvable) {\n        guild = this.client.guilds.resolve(guild)!;\n        if (!guild) throw new PlayerError('Unknown Guild', ErrorStatusCode.UNKNOWN_GUILD);\n        const prev = this.getQueue<T>(guild)!;\n\n        try {\n            prev.destroy();\n        } catch {} // eslint-disable-line no-empty\n        this.queues.delete(guild.id);\n\n        return prev;\n    }\n\n    /**\n     * @typedef {object} PlayerSearchResult\n     * @property {Playlist} [playlist] The playlist (if any)\n     * @property {Track[]} tracks The tracks\n     */\n    /**\n     * Search tracks\n     * @param {string|Track} query The search query\n     * @param {SearchOptions} options The search options\n     * @returns {Promise<SearchResult>}\n     */\n    async search(query: string | Track, options: SearchOptions): Promise<SearchResult> {\n        if (options.requestedBy != null) options.requestedBy = this.client.users.resolve(options.requestedBy)!;\n        if (query instanceof Track)\n            return new SearchResult(this, {\n                playlist: query.playlist || null,\n                tracks: [query],\n                query: query.toString(),\n                extractor: null,\n                queryType: QueryType.AUTO,\n                requestedBy: options.requestedBy\n            });\n        if (!options) throw new PlayerError('DiscordPlayer#search needs search options!', ErrorStatusCode.INVALID_ARG_TYPE);\n\n        let extractor: BaseExtractor | null = null;\n\n        options.searchEngine ??= QueryType.AUTO;\n\n        const queryType = options.searchEngine === QueryType.AUTO ? QueryResolver.resolve(query) : options.searchEngine;\n\n        if (options.searchEngine.startsWith('ext:')) {\n            extractor = this.extractors.get(options.searchEngine.substring(4))!;\n            if (!extractor) return new SearchResult(this, { query, queryType });\n        }\n\n        if (!extractor) {\n            extractor = (await this.extractors.run((ext) => ext.validate(query, queryType as SearchQueryType)))?.extractor || null;\n        }\n\n        // no extractors available\n        if (!extractor) {\n            return new SearchResult(this, { query, queryType });\n        }\n\n        const res = await extractor\n            .handle(query, {\n                type: queryType as SearchQueryType,\n                requestedBy: options.requestedBy as User\n            })\n            .catch(() => null);\n\n        if (res) {\n            return new SearchResult(this, {\n                query,\n                queryType,\n                playlist: res.playlist,\n                tracks: res.tracks,\n                extractor\n            });\n        }\n\n        const result = await this.extractors.run(\n            async (ext) =>\n                (await ext.validate(query)) &&\n                ext.handle(query, {\n                    type: queryType as SearchQueryType,\n                    requestedBy: options.requestedBy as User\n                })\n        );\n        if (!result?.result) return new SearchResult(this, { query, queryType });\n\n        return new SearchResult(this, {\n            query,\n            queryType,\n            playlist: result.result.playlist,\n            tracks: result.result.tracks,\n            extractor: result.extractor\n        });\n    }\n\n    /**\n     * Generates a report of the dependencies used by the `@discordjs/voice` module. Useful for debugging.\n     * @returns {string}\n     */\n    scanDeps() {\n        const line = '-'.repeat(50);\n        const depsReport = generateDependencyReport();\n        const extractorReport = this.extractors.store\n            .map((m) => {\n                return m.identifier;\n            })\n            .join('\\n');\n        return `${depsReport}\\n${line}\\nLoaded Extractors:\\n${extractorReport || 'None'}`;\n    }\n\n    emit<U extends keyof PlayerEvents>(eventName: U, ...args: Parameters<PlayerEvents[U]>): boolean {\n        if (this.requiredEvents.includes(eventName) && !super.eventNames().includes(eventName)) {\n            // eslint-disable-next-line no-console\n            console.error(...args);\n            process.emitWarning(`[DiscordPlayerWarning] Unhandled \"${eventName}\" event! Events ${this.requiredEvents.map((m) => `\"${m}\"`).join(', ')} must have event listeners!`);\n            return false;\n        } else {\n            return super.emit(eventName, ...args);\n        }\n    }\n\n    /**\n     * Resolves queue\n     * @param {GuildResolvable|Queue} queueLike Queue like object\n     * @returns {Queue}\n     */\n    resolveQueue<T>(queueLike: GuildResolvable | Queue): Queue<T> {\n        return this.getQueue(queueLike instanceof Queue ? queueLike.guild : queueLike)!;\n    }\n\n    *[Symbol.iterator]() {\n        yield* Array.from(this.queues.values());\n    }\n\n    /**\n     * Creates `Playlist` instance\n     * @param data The data to initialize a playlist\n     */\n    createPlaylist(data: PlaylistInitData) {\n        return new Playlist(this, data);\n    }\n}\n\nexport { Player };\n","import { Guild, StageChannel, VoiceChannel, SnowflakeUtil, GuildChannelResolvable, ChannelType } from 'discord.js';\nimport { Player } from '../Player';\nimport { StreamDispatcher } from '../VoiceInterface/StreamDispatcher';\nimport Track from './Track';\nimport { PlayerOptions, PlayerProgressbarOptions, PlayOptions, QueueFilters, QueueRepeatMode, SearchQueryType } from '../types/types';\nimport { AudioResource, StreamType } from '@discordjs/voice';\nimport { Util } from '../utils/Util';\nimport AudioFilters from '../utils/AudioFilters';\nimport { PlayerError, ErrorStatusCode } from './PlayerError';\nimport type { Readable } from 'stream';\nimport { VolumeTransformer } from '../VoiceInterface/VolumeTransformer';\nimport { createFFmpegStream } from '../utils/FFmpegStream';\nimport os from 'os';\nimport { parentPort } from 'worker_threads';\nimport type { BiquadFilters, EqualizerBand, PCMFilters } from '@discord-player/equalizer';\nimport { Collection } from '@discord-player/utils';\nimport { QueryResolver } from '../utils/QueryResolver';\nimport { YouTube } from 'youtube-sr';\n\nconst OBCS_DEFAULT = async () => {\n    return undefined;\n};\n\nclass Queue<T = unknown> {\n    public readonly guild: Guild;\n    public readonly player: Player;\n    public connection!: StreamDispatcher;\n    public tracks: Track[] = [];\n    public previousTracks: Track[] = [];\n    public options: PlayerOptions;\n    public playing = false;\n    public metadata?: T | null = null;\n    public repeatMode: QueueRepeatMode = 0;\n    public readonly id = SnowflakeUtil.generate().toString();\n    private _streamTime = 0;\n    public _cooldownsTimeout = new Collection<string, NodeJS.Timeout>();\n    private _activeFilters: any[] = []; // eslint-disable-line @typescript-eslint/no-explicit-any\n    private _filtersUpdate = false;\n    private _lastEQBands: EqualizerBand[] = [];\n    private _lastAudioFilters: PCMFilters[] = [];\n    private _lastBiquadFilter!: BiquadFilters;\n    #destroyed = false;\n    public onBeforeCreateStream: (track: Track, source: SearchQueryType, queue: Queue) => Promise<Readable | undefined> = OBCS_DEFAULT;\n\n    /**\n     * Queue constructor\n     * @param {Player} player The player that instantiated this queue\n     * @param {Guild} guild The guild that instantiated this queue\n     * @param {PlayerOptions} [options] Player options for the queue\n     */\n    constructor(player: Player, guild: Guild, options: PlayerOptions = {}) {\n        /**\n         * The player that instantiated this queue\n         * @type {Player}\n         * @readonly\n         */\n        this.player = player;\n\n        /**\n         * The guild that instantiated this queue\n         * @type {Guild}\n         * @readonly\n         */\n        this.guild = guild;\n\n        /**\n         * The player options for this queue\n         * @type {PlayerOptions}\n         */\n        this.options = {};\n\n        /**\n         * Queue repeat mode\n         * @type {QueueRepeatMode}\n         * @name Queue#repeatMode\n         */\n\n        /**\n         * Queue metadata\n         * @type {any}\n         * @name Queue#metadata\n         */\n\n        /**\n         * Previous tracks\n         * @type {Track[]}\n         * @name Queue#previousTracks\n         */\n\n        /**\n         * Regular tracks\n         * @type {Track[]}\n         * @name Queue#tracks\n         */\n\n        /**\n         * The connection\n         * @type {StreamDispatcher}\n         * @name Queue#connection\n         */\n\n        /**\n         * The ID of this queue\n         * @type {Snowflake}\n         * @name Queue#id\n         */\n\n        Object.assign(\n            this.options,\n            {\n                leaveOnEnd: true,\n                leaveOnStop: true,\n                leaveOnEmpty: true,\n                leaveOnEndCooldown: 1000,\n                leaveOnEmptyCooldown: 1000,\n                autoSelfDeaf: true,\n                ytdlOptions: {\n                    highWaterMark: 1 << 25\n                },\n                initialVolume: 100,\n                bufferingTimeout: 3000,\n                spotifyBridge: true,\n                disableVolume: false,\n                disableEqualizer: false,\n                equalizerBands: [],\n                disableBiquad: false,\n                disableFilters: false,\n                defaultFilters: []\n            } as PlayerOptions,\n            options\n        );\n\n        if (Array.isArray(options.equalizerBands)) this._lastEQBands = options.equalizerBands;\n        if (Array.isArray(options.defaultFilters)) this._lastAudioFilters = options.defaultFilters;\n        if (options.biquadFilter != null) this._lastBiquadFilter = options.biquadFilter;\n        // eslint-disable-next-line\n        if ('onBeforeCreateStream' in this.options) this.onBeforeCreateStream = this.options.onBeforeCreateStream!;\n\n        this.player.emit('debug', this, `Queue initialized:\\n\\n${this.player.scanDeps()}`);\n    }\n\n    /**\n     * Whether or not the PCM filterer is available\n     */\n    public isFiltersAvailable() {\n        return this.connection.audioFilters != null;\n    }\n\n    /**\n     * The PCM filterer\n     */\n    public get filters() {\n        return this.connection.audioFilters;\n    }\n\n    /**\n     * Check if biquad filter is available\n     */\n    public isBiquadEnabled() {\n        return this.connection.biquad != null;\n    }\n\n    /**\n     * Check if the equalizer is turned off\n     */\n    public isBiquadOff() {\n        return this.isBiquadEnabled() && !this.connection.biquad!.disabled;\n    }\n\n    /**\n     * Toggles biquad on/off\n     */\n    public toggleBiquad() {\n        const eq = this.connection.biquad;\n        if (!eq) return false;\n        eq.toggle();\n        return !eq.disabled;\n    }\n\n    /**\n     * Enables biquad\n     */\n    public enableBiquad() {\n        const eq = this.connection.biquad;\n        if (!eq) return false;\n        eq.enable();\n        return !eq.disabled;\n    }\n\n    /**\n     * Disables biquad\n     */\n    public disableBiquad() {\n        const eq = this.connection.biquad;\n        if (!eq) return false;\n        eq.disable();\n        return eq.disabled;\n    }\n\n    /**\n     * Biquad filter setter\n     */\n    public setBiquadFilter(filter: BiquadFilters) {\n        if (!this.isBiquadEnabled()) return;\n        this.connection.biquad!.setFilter(filter);\n        this._lastBiquadFilter = filter;\n    }\n\n    /**\n     * Get active biquad filter name\n     */\n    public getBiquadFilterName() {\n        return this.connection.biquad?.getFilterName();\n    }\n\n    /**\n     * Returns current biquad filter\n     */\n    public getBiquadFilter() {\n        return this.connection.biquad?.filter;\n    }\n\n    /**\n     * Set biquad filter gain value\n     * @param gain The gain to set\n     */\n    public setBiquadGain(gain: number) {\n        return this.connection.biquad?.setGain(gain);\n    }\n\n    /**\n     * Set biquad cutoff frequency value\n     * @param val The value to set\n     */\n    public setBiquadCutoff(val: number) {\n        return this.connection.biquad?.setCutoff(val);\n    }\n\n    /**\n     * Set biquad sample rate value\n     * @param val The value to set\n     */\n    public setBiquadSampleRate(val: number) {\n        return this.connection.biquad?.setSample(val);\n    }\n\n    /**\n     * Set biquad Q value\n     * @param val The value to set\n     */\n    public setBiquadQ(val: number) {\n        return this.connection.biquad?.setQ(val);\n    }\n\n    /**\n     * Set equalizer bands\n     * @param bands Equalizer band multiplier array\n     */\n    public setEqualizer(bands?: EqualizerBand[]) {\n        if (!this.connection.equalizer) return false;\n\n        if (!Array.isArray(bands) || !bands.length) {\n            this.connection.equalizer.resetEQ();\n            this._lastEQBands = this.getEqualizer();\n        } else {\n            this.connection.equalizer.setEQ(bands);\n            this._lastEQBands = this.getEqualizer();\n        }\n\n        return true;\n    }\n\n    /**\n     * Set particular equalizer band multiplier\n     * @param band The band to update\n     * @param gain The gain\n     */\n    public setEqualizerBand(band: number, gain: number) {\n        if (!this.connection.equalizer) return null;\n        this.connection.equalizer.equalizer.setGain(band, gain);\n        this._lastEQBands = this.getEqualizer();\n        return true;\n    }\n\n    /**\n     * Returns gain value of specific equalizer band\n     * @param band The band to get value of\n     */\n    public getEqualizerBand(band: number) {\n        if (!this.connection.equalizer) return null;\n        return this.connection.equalizer.equalizer.getGain(band);\n    }\n\n    /**\n     * Returns entire equalizer bands\n     */\n    public getEqualizer() {\n        if (!this.connection.equalizer) return [];\n        return this.connection.equalizer.getEQ();\n    }\n\n    /**\n     * Check if equalizer is enabled\n     */\n    public isEqualizerEnabled() {\n        return this.connection.equalizer != null;\n    }\n\n    /**\n     * Check if the equalizer is turned off\n     */\n    public isEqualizerOff() {\n        return this.isEqualizerEnabled() && !this.connection.equalizer!.disabled;\n    }\n\n    /**\n     * Toggles equalizer on/off\n     */\n    public toggleEqualizer() {\n        const eq = this.connection.equalizer;\n        if (!eq) return false;\n        eq.toggle();\n        return !eq.disabled;\n    }\n\n    /**\n     * Enables equalizer\n     */\n    public enableEqualizer() {\n        const eq = this.connection.equalizer;\n        if (!eq) return false;\n        eq.enable();\n        return !eq.disabled;\n    }\n\n    /**\n     * Disables equalizer\n     */\n    public disableEqualizer() {\n        const eq = this.connection.equalizer;\n        if (!eq) return false;\n        eq.disable();\n        return eq.disabled;\n    }\n\n    /**\n     * Forces next play\n     * @returns {Promise<void>}\n     */\n    public async forceNext() {\n        if (this.connection.audioResource) {\n            this.connection.emit('finish', this.connection.audioResource);\n        } else if (this.tracks.length) {\n            await this.play();\n        }\n    }\n\n    /**\n     * Returns current track\n     * @type {Track}\n     */\n    get current() {\n        if (this.#watchDestroyed()) return;\n        return this.connection.audioResource?.metadata ?? this.tracks[0];\n    }\n\n    /**\n     * If this queue is destroyed\n     * @type {boolean}\n     */\n    get destroyed() {\n        return this.#destroyed;\n    }\n\n    /**\n     * Returns current track\n     * @returns {Track}\n     */\n    nowPlaying() {\n        if (this.#watchDestroyed()) return;\n        return this.current;\n    }\n\n    /**\n     * Connects to a voice channel\n     * @param {GuildChannelResolvable} channel The voice/stage channel\n     * @returns {Promise<Queue>}\n     */\n    async connect(channel: GuildChannelResolvable) {\n        if (this.#watchDestroyed()) return;\n        const _channel = this.guild.channels.resolve(channel) as StageChannel | VoiceChannel;\n        if (![ChannelType.GuildStageVoice, ChannelType.GuildVoice].includes(_channel?.type))\n            throw new PlayerError(`Channel type must be GuildVoice or GuildStageVoice, got ${_channel?.type}!`, ErrorStatusCode.INVALID_ARG_TYPE);\n        const connection = await this.player.voiceUtils.connect(_channel, {\n            deaf: this.options.autoSelfDeaf\n        });\n        this.connection = connection;\n\n        if (_channel.type === ChannelType.GuildStageVoice) {\n            await _channel.guild.members.me!.voice.setSuppressed(false).catch(async () => {\n                return await _channel.guild.members.me!.voice.setRequestToSpeak(true).catch(Util.noop);\n            });\n        }\n\n        this.connection.on('audioFilters', (filters) => {\n            this._lastAudioFilters = filters;\n        });\n\n        this.connection.on('error', (err) => {\n            if (this.#watchDestroyed(false)) return;\n            this.player.emit('connectionError', this, err);\n        });\n        this.connection.on('debug', (msg) => {\n            if (this.#watchDestroyed(false)) return;\n            this.player.emit('debug', this, msg);\n        });\n\n        this.player.emit('connectionCreate', this, this.connection);\n\n        this.connection.on('start', (resource) => {\n            if (this.#watchDestroyed(false)) return;\n            this.playing = true;\n            if (!this._filtersUpdate) this.player.emit('trackStart', this, resource?.metadata ?? this.current);\n            this._filtersUpdate = false;\n        });\n\n        this.connection.on('finish', async (resource) => {\n            if (this.#watchDestroyed(false)) return;\n            this.playing = false;\n            if (this._filtersUpdate) return;\n            this._streamTime = 0;\n\n            this.player.emit('trackEnd', this, resource.metadata);\n\n            if (!this.tracks.length && this.repeatMode === QueueRepeatMode.OFF) {\n                this.emitEnd();\n            } else if (!this.tracks.length && this.repeatMode === QueueRepeatMode.AUTOPLAY) {\n                this._handleAutoplay(Util.last(this.previousTracks));\n            } else {\n                if (this.repeatMode === QueueRepeatMode.TRACK) return void this.play(Util.last(this.previousTracks), { immediate: true });\n                if (this.repeatMode === QueueRepeatMode.QUEUE) this.tracks.push(Util.last(this.previousTracks));\n                const nextTrack = this.tracks.shift();\n                this.play(nextTrack, { immediate: true });\n                return;\n            }\n        });\n\n        return this;\n    }\n\n    private emitEnd() {\n        const timeout = setTimeout(() => {\n            if (!this.player.queues.has(this.guild.id)) return;\n            if (this.tracks.length || this.current) return;\n            if (this.options.leaveOnEnd) this.destroy();\n            this.player.emit('queueEnd', this);\n        }, this.options.leaveOnEndCooldown || 0).unref();\n\n        this._cooldownsTimeout.set(`queueEnd_${this.guild.id}`, timeout);\n    }\n\n    private refreshEndCooldown() {\n        const existingTimeout = this._cooldownsTimeout.get(`queueEnd_${this.guild.id}`);\n        if (this.tracks.length || this.current) {\n            clearTimeout(existingTimeout);\n            this._cooldownsTimeout.delete(`queueEnd_${this.guild.id}`);\n        }\n    }\n\n    /**\n     * Destroys this queue\n     * @param {boolean} [disconnect=this.options.leaveOnStop] If it should leave on destroy\n     * @returns {void}\n     */\n    destroy(disconnect = this.options.leaveOnStop) {\n        if (this.#watchDestroyed()) return;\n        if (this.connection) this.connection.end();\n        if (disconnect) this.connection?.disconnect();\n        this.player.queues.delete(this.guild.id);\n        this.player.voiceUtils.cache.delete(this.guild.id);\n        this.#destroyed = true;\n    }\n\n    /**\n     * Skips current track\n     * @returns {boolean}\n     */\n    skip() {\n        if (this.#watchDestroyed()) return;\n        if (!this.connection) return false;\n        this._filtersUpdate = false;\n        this.connection.end();\n        return true;\n    }\n\n    /**\n     * Adds single track to the queue\n     * @param {Track} track The track to add\n     * @returns {void}\n     */\n    addTrack(track: Track) {\n        if (this.#watchDestroyed()) return;\n        if (!(track instanceof Track)) throw new PlayerError('invalid track', ErrorStatusCode.INVALID_TRACK);\n        this.tracks.push(track);\n        this.refreshEndCooldown();\n        this.player.emit('trackAdd', this, track);\n    }\n\n    /**\n     * Adds multiple tracks to the queue\n     * @param {Track[]} tracks Array of tracks to add\n     */\n    addTracks(tracks: Track[]) {\n        if (this.#watchDestroyed()) return;\n        if (!tracks.every((y) => y instanceof Track)) throw new PlayerError('invalid track', ErrorStatusCode.INVALID_TRACK);\n        this.tracks.push(...tracks);\n        this.refreshEndCooldown();\n        this.player.emit('tracksAdd', this, tracks);\n    }\n\n    /**\n     * Sets paused state\n     * @param {boolean} paused The paused state\n     * @returns {boolean}\n     */\n    setPaused(paused?: boolean) {\n        if (this.#watchDestroyed()) return false;\n        if (!this.connection) return false;\n        return paused ? this.connection.pause(true) : this.connection.resume();\n    }\n\n    /**\n     * If the player is currently paused\n     */\n    get paused() {\n        return this.connection.paused;\n    }\n\n    set paused(val: boolean) {\n        this.setPaused(val);\n    }\n\n    /**\n     * Pause the playback\n     */\n    pause() {\n        return this.setPaused(true);\n    }\n\n    /**\n     * Resume the playback\n     */\n    resume() {\n        return this.setPaused(false);\n    }\n\n    /**\n     * Sets bitrate\n     * @param  {number|auto} bitrate bitrate to set\n     * @returns {void}\n     */\n    setBitrate(bitrate: number | 'auto') {\n        if (this.#watchDestroyed()) return;\n        if (!this.connection?.audioResource?.encoder) return;\n        if (bitrate === 'auto') bitrate = this.connection.channel?.bitrate ?? 64000;\n        this.connection.audioResource.encoder.setBitrate(bitrate);\n    }\n\n    /**\n     * Sets volume\n     * @param {number} amount The volume amount\n     * @returns {boolean}\n     */\n    setVolume(amount: number) {\n        if (this.#watchDestroyed()) return;\n        if (!this.connection) return false;\n        this.options.initialVolume = amount;\n        return this.connection.setVolume(amount);\n    }\n    /**\n     * Sets repeat mode\n     * @param  {QueueRepeatMode} mode The repeat mode\n     * @returns {boolean}\n     */\n    setRepeatMode(mode: QueueRepeatMode) {\n        if (this.#watchDestroyed()) return;\n        if (![QueueRepeatMode.OFF, QueueRepeatMode.QUEUE, QueueRepeatMode.TRACK, QueueRepeatMode.AUTOPLAY].includes(mode))\n            throw new PlayerError(`Unknown repeat mode \"${mode}\"!`, ErrorStatusCode.UNKNOWN_REPEAT_MODE);\n        if (mode === this.repeatMode) return false;\n        this.repeatMode = mode;\n        return true;\n    }\n\n    /**\n     * The current volume amount\n     * @type {number}\n     */\n    get volume() {\n        if (this.#watchDestroyed()) return 100;\n        if (!this.connection) return 100;\n        return this.connection.volume;\n    }\n\n    set volume(amount: number) {\n        this.setVolume(amount);\n    }\n\n    /**\n     * The stream time of this queue\n     * @type {number}\n     */\n    get streamTime() {\n        if (this.#watchDestroyed()) return 0;\n        if (!this.connection) return 0;\n        const playbackTime = this._streamTime + this.connection.streamTime;\n        const NC = this._activeFilters.includes('nightcore') ? 1.25 : null;\n        const VW = this._activeFilters.includes('vaporwave') ? 0.8 : null;\n\n        if (NC && VW) return playbackTime * (NC + VW);\n        return NC ? playbackTime * NC : VW ? playbackTime * VW : playbackTime;\n    }\n\n    set streamTime(time: number) {\n        if (this.#watchDestroyed()) return;\n        this.seek(time);\n    }\n\n    /**\n     * Returns enabled filters\n     * @returns {AudioFilters}\n     */\n    getFiltersEnabled() {\n        if (this.#watchDestroyed()) return;\n        return AudioFilters.names.filter((x) => this._activeFilters.includes(x));\n    }\n\n    /**\n     * Returns disabled filters\n     * @returns {AudioFilters}\n     */\n    getFiltersDisabled() {\n        if (this.#watchDestroyed()) return;\n        return AudioFilters.names.filter((x) => !this._activeFilters.includes(x));\n    }\n\n    /**\n     * Sets filters\n     * @param {QueueFilters} filters Queue filters\n     * @returns {Promise<void>}\n     */\n    async setFilters(filters?: QueueFilters) {\n        if (this.#watchDestroyed()) return;\n        if (!filters || !Object.keys(filters).length) {\n            // reset filters\n            const streamTime = this.streamTime;\n            this._activeFilters = [];\n            return await this.play(this.current, {\n                immediate: true,\n                filtersUpdate: true,\n                seek: streamTime,\n                encoderArgs: []\n            });\n        }\n\n        const _filters: any[] = []; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n        for (const filter in filters) {\n            if (filters[filter as keyof QueueFilters] === true) _filters.push(filter);\n        }\n\n        if (this._activeFilters.join('') === _filters.join('')) return;\n\n        const newFilters = AudioFilters.create(_filters).trim();\n        const streamTime = this.streamTime;\n        this._activeFilters = _filters;\n\n        return await this.play(this.current, {\n            immediate: true,\n            filtersUpdate: true,\n            seek: streamTime,\n            encoderArgs: !_filters.length ? undefined : ['-af', newFilters]\n        });\n    }\n\n    /**\n     * Seeks to the given time\n     * @param {number} position The position\n     * @returns {boolean}\n     */\n    async seek(position: number) {\n        if (this.#watchDestroyed()) return;\n        if (!this.playing || !this.current) return false;\n        if (position < 1) position = 0;\n        if (position >= this.current.durationMS) return this.skip();\n\n        await this.play(this.current, {\n            immediate: true,\n            filtersUpdate: true, // to stop events\n            seek: position\n        });\n\n        return true;\n    }\n\n    /**\n     * Plays previous track\n     * @returns {Promise<void>}\n     */\n    async back() {\n        if (this.#watchDestroyed()) return;\n        const prev = this.previousTracks[this.previousTracks.length - 2]; // because last item is the current track\n        if (!prev) throw new PlayerError('Could not find previous track', ErrorStatusCode.TRACK_NOT_FOUND);\n\n        return await this.play(prev, { immediate: true });\n    }\n\n    /**\n     * Clear this queue\n     */\n    clear() {\n        if (this.#watchDestroyed()) return;\n        this.tracks = [];\n        this.previousTracks = [];\n    }\n\n    /**\n     * Stops the player\n     * @returns {void}\n     */\n    stop() {\n        if (this.#watchDestroyed()) return;\n        return this.destroy();\n    }\n\n    /**\n     * Shuffles this queue\n     * @returns {boolean}\n     */\n    shuffle() {\n        if (this.#watchDestroyed()) return;\n        if (!this.tracks.length || this.tracks.length < 2) return false;\n\n        for (let i = this.tracks.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [this.tracks[i], this.tracks[j]] = [this.tracks[j], this.tracks[i]];\n        }\n\n        return true;\n    }\n\n    /**\n     * Removes a track from the queue\n     * @param {Track|string|number} track The track to remove\n     * @returns {Track}\n     */\n    remove(track: Track | string | number) {\n        if (this.#watchDestroyed()) return;\n        let trackFound: Track | null = null;\n        if (typeof track === 'number') {\n            trackFound = this.tracks[track];\n            if (trackFound) {\n                this.tracks = this.tracks.filter((t) => t.id !== trackFound!.id);\n            }\n        } else {\n            trackFound = this.tracks.find((s) => s.id === (track instanceof Track ? track.id : track))!;\n            if (trackFound) {\n                this.tracks = this.tracks.filter((s) => s.id !== trackFound!.id);\n            }\n        }\n\n        return trackFound;\n    }\n\n    /**\n     * Returns the index of the specified track. If found, returns the track index else returns -1.\n     * @param {number|Track|string} track The track\n     * @returns {number}\n     */\n    getTrackPosition(track: number | Track | string) {\n        if (this.#watchDestroyed()) return;\n        if (typeof track === 'number') return this.tracks[track] != null ? track : -1;\n        return this.tracks.findIndex((pred) => pred.id === (track instanceof Track ? track.id : track));\n    }\n\n    /**\n     * Jumps to particular track\n     * @param {Track|number} track The track\n     * @returns {void}\n     */\n    jump(track: Track | number): void {\n        if (this.#watchDestroyed()) return;\n        const foundTrack = this.remove(track);\n        if (!foundTrack) throw new PlayerError('Track not found', ErrorStatusCode.TRACK_NOT_FOUND);\n\n        this.tracks.splice(0, 0, foundTrack);\n\n        return void this.skip();\n    }\n\n    /**\n     * Jumps to particular track, removing other tracks on the way\n     * @param {Track|number} track The track\n     * @returns {void}\n     */\n    skipTo(track: Track | number): void {\n        if (this.#watchDestroyed()) return;\n        const trackIndex = this.getTrackPosition(track)!;\n        const removedTrack = this.remove(track);\n        if (!removedTrack) throw new PlayerError('Track not found', ErrorStatusCode.TRACK_NOT_FOUND);\n\n        this.tracks.splice(0, trackIndex, removedTrack);\n\n        return void this.skip();\n    }\n\n    /**\n     * Inserts the given track to specified index\n     * @param {Track} track The track to insert\n     * @param {number} [index=0] The index where this track should be\n     */\n    insert(track: Track, index = 0) {\n        if (this.#watchDestroyed()) return;\n        if (!track || !(track instanceof Track)) throw new PlayerError('track must be the instance of Track', ErrorStatusCode.INVALID_TRACK);\n        if (typeof index !== 'number' || index < 0 || !Number.isFinite(index)) throw new PlayerError(`Invalid index \"${index}\"`, ErrorStatusCode.INVALID_ARG_TYPE);\n\n        this.tracks.splice(index, 0, track);\n\n        this.player.emit('trackAdd', this, track);\n    }\n\n    /**\n     * @typedef {object} PlayerTimestamp\n     * @property {string} current The current progress\n     * @property {string} end The total time\n     * @property {number} progress Progress in %\n     */\n\n    /**\n     * Returns player stream timestamp\n     * @returns {PlayerTimestamp}\n     */\n    getPlayerTimestamp() {\n        if (this.#watchDestroyed()) return;\n        const currentStreamTime = this.streamTime;\n        const totalTime = this.current!.durationMS;\n\n        const currentTimecode = Util.buildTimeCode(Util.parseMS(currentStreamTime));\n        const endTimecode = Util.buildTimeCode(Util.parseMS(totalTime));\n\n        return {\n            current: currentTimecode,\n            end: endTimecode,\n            progress: Math.round((currentStreamTime / totalTime) * 100)\n        };\n    }\n\n    /**\n     * Creates progress bar string\n     * @param {PlayerProgressbarOptions} options The progress bar options\n     * @returns {string}\n     */\n    createProgressBar(options: PlayerProgressbarOptions = { timecodes: true }) {\n        if (this.#watchDestroyed()) return;\n        const length = typeof options.length === 'number' ? (options.length <= 0 || options.length === Infinity ? 15 : options.length) : 15;\n\n        const index = Math.round((this.streamTime / this.current!.durationMS) * length);\n        const indicator = typeof options.indicator === 'string' && options.indicator.length > 0 ? options.indicator : '';\n        const line = typeof options.line === 'string' && options.line.length > 0 ? options.line : '';\n\n        if (index >= 1 && index <= length) {\n            const bar = line.repeat(length - 1).split('');\n            bar.splice(index, 0, indicator);\n            if (options.timecodes) {\n                const timestamp = this.getPlayerTimestamp()!;\n                return `${timestamp.current}  ${bar.join('')}  ${timestamp.end}`;\n            } else {\n                return `${bar.join('')}`;\n            }\n        } else {\n            if (options.timecodes) {\n                const timestamp = this.getPlayerTimestamp()!;\n                return `${timestamp.current}  ${indicator}${line.repeat(length - 1)}  ${timestamp.end}`;\n            } else {\n                return `${indicator}${line.repeat(length - 1)}`;\n            }\n        }\n    }\n\n    /**\n     * Total duration\n     * @type {Number}\n     */\n    get totalTime(): number {\n        if (this.#watchDestroyed()) return 0;\n        return this.tracks.length > 0 ? this.tracks.map((t) => t.durationMS).reduce((p, c) => p + c) : 0;\n    }\n\n    /**\n     * Generates statistics\n     */\n    generateStatistics() {\n        return {\n            guild: this.guild.id,\n            memory: process.memoryUsage(),\n            tracks: this.tracks.length,\n            os: {\n                cpuCount: os.cpus().length,\n                totalMem: os.totalmem(),\n                freeMem: os.freemem(),\n                platform: process.platform\n            },\n            isShard: typeof process.send === 'function' || parentPort != null,\n            latency: {\n                client: this.player.client.ws.ping,\n                udp: this.connection.voiceConnection.ping.udp,\n                ws: this.connection.voiceConnection.ping.ws,\n                eventLoop: this.player.eventLoopLag\n            },\n            subscribers: this.player.queues.size,\n            connections: this.player.queues.filter((x) => x.connection?.voiceConnection != null).size,\n            extractors: this.player.extractors.size\n        };\n    }\n\n    /**\n     * Voice connection latency in ms\n     * @type {number}\n     */\n    public get ping() {\n        return this.connection.voiceConnection.ping.udp;\n    }\n\n    /**\n     * Play stream in a voice/stage channel\n     * @param {Track} [src] The track to play (if empty, uses first track from the queue)\n     * @param {PlayOptions} [options] The options\n     * @returns {Promise<void>}\n     */\n    async play(src?: Track, options: PlayOptions = {}): Promise<void> {\n        if (this.#watchDestroyed(false)) return;\n        if (!this.connection || !this.connection.voiceConnection) throw new PlayerError('Voice connection is not available, use <Queue>.connect()!', ErrorStatusCode.NO_CONNECTION);\n        if (src && (this.playing || this.tracks.length) && !options.immediate) return this.addTrack(src);\n        const track = options.filtersUpdate && !options.immediate ? src || this.current : src ?? this.tracks.shift();\n        if (!track) return;\n\n        this.player.emit('debug', this, 'Received play request');\n\n        if (!options.filtersUpdate) {\n            this.previousTracks = this.previousTracks.filter((x) => x.id !== track.id);\n            this.previousTracks.push(track);\n        }\n\n        let stream: string | Readable | null = null;\n        const hasCustomDownloader = typeof this.onBeforeCreateStream === 'function';\n        if (hasCustomDownloader) {\n            const qt: SearchQueryType = track.queryType || (track.raw.source === 'spotify' ? 'spotifySong' : track.raw.source === 'apple_music' ? 'appleMusicSong' : track.raw.source) || 'arbitrary';\n            stream = (await this.onBeforeCreateStream(track, qt, this)) || null;\n        }\n\n        if (!stream) {\n            const streamInfo = await this.player.extractors.run(async (extractor) => {\n                const canStream = await extractor.validate(track.url, track.queryType || QueryResolver.resolve(track.url));\n                if (!canStream) return false;\n                return await extractor.stream(track);\n            });\n            if (!streamInfo || !streamInfo.result) {\n                this.player.emit('error', this, new Error('No stream extractors are available for this track'));\n                return void this.play(this.tracks.shift(), { immediate: true });\n            }\n\n            stream = streamInfo.result;\n        }\n\n        const ffmpegStream = createFFmpegStream(stream, {\n            encoderArgs: options.encoderArgs || this._activeFilters.length ? ['-af', AudioFilters.create(this._activeFilters)] : [],\n            seek: options.seek ? options.seek / 1000 : 0,\n            fmt: 's16le'\n        }).on('error', (err) => {\n            if (!`${err}`.toLowerCase().includes('premature close')) this.player.emit('error', this, err);\n        });\n\n        const resource: AudioResource<Track> = this.connection.createStream(ffmpegStream, {\n            type: StreamType.Raw,\n            data: track,\n            disableVolume: Boolean(this.options.disableVolume),\n            disableEqualizer: Boolean(this.options.disableEqualizer),\n            eq: this._lastEQBands,\n            disableBiquad: Boolean(this.options.disableBiquad),\n            biquadFilter: this._lastBiquadFilter,\n            defaultFilters: this._lastAudioFilters,\n            disableFilters: Boolean(this.options.disableFilters)\n        });\n\n        if (options.seek) this._streamTime = options.seek;\n        this._filtersUpdate = options.filtersUpdate!;\n\n        const volumeTransformer = resource.volume as VolumeTransformer;\n        if (volumeTransformer && typeof this.options.initialVolume === 'number') volumeTransformer.setVolume(Math.pow(this.options.initialVolume / 100, 1.660964));\n        if (volumeTransformer?.hasSmoothness && typeof this.options.volumeSmoothness === 'number') {\n            if (typeof volumeTransformer.setSmoothness === 'function') volumeTransformer.setSmoothness(this.options.volumeSmoothness || 0);\n        }\n\n        setTimeout(() => {\n            this.connection.playStream(resource);\n        }, this.#getBufferingTimeout()).unref();\n    }\n\n    /**\n     * Private method to handle autoplay\n     * @param {Track} track The source track to find its similar track for autoplay\n     * @returns {Promise<void>}\n     * @private\n     */\n    private async _handleAutoplay(track: Track): Promise<void> {\n        if (this.#watchDestroyed()) return;\n        if (!track || ![track.source, track.raw?.source].includes('youtube')) {\n            return this.emitEnd();\n        }\n        let info = await YouTube.getVideo(track.url)\n            .then((x) => x.videos![0])\n            .catch(Util.noop);\n        // fallback\n        if (!info)\n            info = await YouTube.search(track.author)\n                .then((x) => x[0])\n                .catch(Util.noop);\n        if (!info) {\n            return this.emitEnd();\n        }\n\n        const nextTrack = new Track(this.player, {\n            title: info.title!,\n            url: `https://www.youtube.com/watch?v=${info.id}`,\n            duration: info.durationFormatted || Util.buildTimeCode(Util.parseMS(info.duration * 1000)),\n            description: '',\n            thumbnail: typeof info.thumbnail === 'string' ? info.thumbnail! : info.thumbnail!.url!,\n            views: info.views,\n            author: info.channel!.name!,\n            requestedBy: track.requestedBy,\n            source: 'youtube',\n            queryType: 'youtubeVideo'\n        });\n\n        this.play(nextTrack, { immediate: true });\n    }\n\n    *[Symbol.iterator]() {\n        if (this.#watchDestroyed()) return;\n        yield* this.tracks;\n    }\n\n    /**\n     * JSON representation of this queue\n     * @returns {object}\n     */\n    toJSON() {\n        if (this.#watchDestroyed()) return;\n        return {\n            id: this.id,\n            guild: this.guild.id,\n            voiceChannel: this.connection?.channel?.id,\n            options: this.options,\n            tracks: this.tracks.map((m) => m.toJSON())\n        };\n    }\n\n    /**\n     * String representation of this queue\n     * @returns {string}\n     */\n    toString() {\n        if (this.#watchDestroyed()) return;\n        if (!this.tracks.length) return 'No songs available to display!';\n        return `**Upcoming Songs:**\\n${this.tracks.map((m, i) => `${i + 1}. **${m.title}**`).join('\\n')}`;\n    }\n\n    #watchDestroyed(emit = true) {\n        if (this.#destroyed) {\n            if (emit) this.player.emit('error', this, new PlayerError('Cannot use destroyed queue', ErrorStatusCode.DESTROYED_QUEUE));\n            return true;\n        }\n\n        return false;\n    }\n\n    #getBufferingTimeout() {\n        const timeout = this.options.bufferingTimeout!;\n\n        if (isNaN(timeout) || timeout < 0 || !Number.isFinite(timeout)) return 1000;\n        return timeout;\n    }\n}\n\nexport { Queue };\n","import { User, escapeMarkdown, SnowflakeUtil } from 'discord.js';\nimport { Player } from '../Player';\nimport { RawTrackData, SearchQueryType, TrackJSON } from '../types/types';\nimport { Playlist } from './Playlist';\nimport { Queue } from './Queue';\n\nclass Track {\n    public player!: Player;\n    public title!: string;\n    public description!: string;\n    public author!: string;\n    public url!: string;\n    public thumbnail!: string;\n    public duration!: string;\n    public views!: number;\n    public requestedBy: User | null = null;\n    public playlist?: Playlist;\n    public queryType: SearchQueryType | null | undefined = null;\n    public readonly raw: RawTrackData = {} as RawTrackData;\n    public readonly id = SnowflakeUtil.generate().toString();\n\n    /**\n     * Track constructor\n     * @param {Player} player The player that instantiated this Track\n     * @param {RawTrackData} data Track data\n     */\n    constructor(player: Player, data: RawTrackData) {\n        /**\n         * The player that instantiated this Track\n         * @name Track#player\n         * @type {Player}\n         * @readonly\n         */\n        Object.defineProperty(this, 'player', { value: player, enumerable: false });\n\n        /**\n         * Title of this track\n         * @name Track#title\n         * @type {string}\n         */\n\n        /**\n         * Description of this track\n         * @name Track#description\n         * @type {string}\n         */\n\n        /**\n         * Author of this track\n         * @name Track#author\n         * @type {string}\n         */\n\n        /**\n         * URL of this track\n         * @name Track#url\n         * @type {string}\n         */\n\n        /**\n         * Thumbnail of this track\n         * @name Track#thumbnail\n         * @type {string}\n         */\n\n        /**\n         * Duration of this track\n         * @name Track#duration\n         * @type {string}\n         */\n\n        /**\n         * Views count of this track\n         * @name Track#views\n         * @type {number}\n         */\n\n        /**\n         * Person who requested this track\n         * @name Track#requestedBy\n         * @type {User}\n         */\n\n        /**\n         * If this track belongs to playlist\n         * @name Track#fromPlaylist\n         * @type {boolean}\n         */\n\n        /**\n         * Raw track data\n         * @name Track#raw\n         * @type {RawTrackData}\n         */\n\n        /**\n         * The track id\n         * @name Track#id\n         * @type {Snowflake}\n         * @readonly\n         */\n\n        /**\n         * The playlist which track belongs\n         * @name Track#playlist\n         * @type {Playlist}\n         */\n\n        void this._patch(data);\n    }\n\n    private _patch(data: RawTrackData) {\n        this.title = escapeMarkdown(data.title ?? '');\n        this.author = data.author ?? '';\n        this.url = data.url ?? '';\n        this.thumbnail = data.thumbnail ?? '';\n        this.duration = data.duration ?? '';\n        this.views = data.views ?? 0;\n        this.queryType = data.queryType;\n        this.requestedBy = data.requestedBy || null;\n        this.playlist = data.playlist;\n\n        // raw\n        Object.defineProperty(this, 'raw', { value: Object.assign({}, { source: data.raw?.source ?? data.source }, data.raw ?? data), enumerable: false });\n    }\n\n    /**\n     * The queue in which this track is located\n     * @type {Queue}\n     */\n    get queue(): Queue {\n        return this.player.queues.find((q) => q.tracks.some((ab) => ab.id === this.id))!;\n    }\n\n    /**\n     * The track duration in millisecond\n     * @type {number}\n     */\n    get durationMS(): number {\n        const times = (n: number, t: number) => {\n            let tn = 1;\n            for (let i = 0; i < t; i++) tn *= n;\n            return t <= 0 ? 1000 : tn * 1000;\n        };\n\n        return this.duration\n            .split(':')\n            .reverse()\n            .map((m, i) => parseInt(m) * times(60, i))\n            .reduce((a, c) => a + c, 0);\n    }\n\n    /**\n     * Returns source of this track\n     * @type {TrackSource}\n     */\n    get source() {\n        return this.raw.source ?? 'arbitrary';\n    }\n\n    /**\n     * String representation of this track\n     * @returns {string}\n     */\n    toString(): string {\n        return `${this.title} by ${this.author}`;\n    }\n\n    /**\n     * Raw JSON representation of this track\n     * @returns {TrackJSON}\n     */\n    toJSON(hidePlaylist?: boolean) {\n        return {\n            id: this.id,\n            title: this.title,\n            description: this.description,\n            author: this.author,\n            url: this.url,\n            thumbnail: this.thumbnail,\n            duration: this.duration,\n            durationMS: this.durationMS,\n            views: this.views,\n            requestedBy: this.requestedBy?.id || null,\n            playlist: hidePlaylist ? null : this.playlist?.toJSON() ?? null\n        } as TrackJSON;\n    }\n}\n\nexport default Track;\n\nexport { Track };\n","import { Snowflake, User, UserResolvable, VoiceState } from 'discord.js';\nimport { Readable, Duplex } from 'stream';\nimport { Queue } from '../Structures/Queue';\nimport Track from '../Structures/Track';\nimport { Playlist } from '../Structures/Playlist';\nimport { StreamDispatcher } from '../VoiceInterface/StreamDispatcher';\nimport { downloadOptions } from 'ytdl-core';\nimport { BiquadFilters, EqualizerBand, PCMFilters } from '@discord-player/equalizer';\n\nexport type FiltersName = keyof QueueFilters;\n\nexport interface PlayerSearchResult {\n    playlist: Playlist | null;\n    tracks: Track[];\n}\n\n/**\n * @typedef {AudioFilters} QueueFilters\n */\nexport interface QueueFilters {\n    bassboost_low?: boolean;\n    bassboost?: boolean;\n    bassboost_high?: boolean;\n    '8D'?: boolean;\n    vaporwave?: boolean;\n    nightcore?: boolean;\n    phaser?: boolean;\n    tremolo?: boolean;\n    vibrato?: boolean;\n    reverse?: boolean;\n    treble?: boolean;\n    normalizer?: boolean;\n    normalizer2?: boolean;\n    surrounding?: boolean;\n    pulsator?: boolean;\n    subboost?: boolean;\n    karaoke?: boolean;\n    flanger?: boolean;\n    gate?: boolean;\n    haas?: boolean;\n    mcompand?: boolean;\n    mono?: boolean;\n    mstlr?: boolean;\n    mstrr?: boolean;\n    compressor?: boolean;\n    expander?: boolean;\n    softlimiter?: boolean;\n    chorus?: boolean;\n    chorus2d?: boolean;\n    chorus3d?: boolean;\n    fadein?: boolean;\n    dim?: boolean;\n    earrape?: boolean;\n}\n\n/**\n * The track source:\n * - soundcloud\n * - youtube\n * - spotify\n * - apple_music\n * - arbitrary\n * @typedef {string} TrackSource\n */\nexport type TrackSource = 'soundcloud' | 'youtube' | 'spotify' | 'apple_music' | 'arbitrary';\n\n/**\n * @typedef {object} RawTrackData\n * @property {string} title The title\n * @property {string} description The description\n * @property {string} author The author\n * @property {string} url The url\n * @property {string} thumbnail The thumbnail\n * @property {string} duration The duration\n * @property {number} views The views\n * @property {User} requestedBy The user who requested this track\n * @property {Playlist} [playlist] The playlist\n * @property {TrackSource} [source=\"arbitrary\"] The source\n * @property {any} [engine] The engine\n * @property {boolean} [live] If this track is live\n * @property {any} [raw] The raw data\n */\nexport interface RawTrackData {\n    title: string;\n    description: string;\n    author: string;\n    url: string;\n    thumbnail: string;\n    duration: string;\n    views: number;\n    requestedBy?: User | null;\n    playlist?: Playlist;\n    source?: TrackSource;\n    engine?: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n    live?: boolean;\n    raw?: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n    queryType?: SearchQueryType;\n}\n\n/**\n * @typedef {object} TimeData\n * @property {number} days Time in days\n * @property {number} hours Time in hours\n * @property {number} minutes Time in minutes\n * @property {number} seconds Time in seconds\n */\nexport interface TimeData {\n    days: number;\n    hours: number;\n    minutes: number;\n    seconds: number;\n}\n\n/**\n * @typedef {object} PlayerProgressbarOptions\n * @property {boolean} [timecodes] If it should render time codes\n * @property {boolean} [queue] If it should create progress bar for the whole queue\n * @property {number} [length] The bar length\n * @property {string} [line] The bar track\n * @property {string} [indicator] The indicator\n */\nexport interface PlayerProgressbarOptions {\n    timecodes?: boolean;\n    length?: number;\n    line?: string;\n    indicator?: string;\n    queue?: boolean;\n}\n\n/**\n * @typedef {object} PlayerOptions\n * @property {boolean} [leaveOnEnd=true] If it should leave on end\n * @property {boolean} [leaveOnStop=true] If it should leave on stop\n * @property {boolean} [leaveOnEmpty=true] If it should leave on empty\n * @property {number} [leaveOnEmptyCooldown=1000] The cooldown in ms\n * @property {number} [leaveOnEndCooldown=1000] The cooldown in ms\n * @property {boolean} [autoSelfDeaf=true] If it should set the bot in deaf mode\n * @property {YTDLDownloadOptions} [ytdlOptions] The youtube download options\n * @property {number} [initialVolume=100] The initial player volume\n * @property {number} [bufferingTimeout=3000] Buffering timeout for the stream\n * @property {boolean} [spotifyBridge=true] If player should bridge spotify source to youtube\n * @property {boolean} [disableVolume=false] If player should disable inline volume\n * @property {boolean} [disableEqualizer=false] If player should disable equalizer\n * @property {boolean} [disableBiquad=false] If player should disable biquad\n * @property {number} [volumeSmoothness=0] The volume transition smoothness between volume changes (lower the value to get better result)\n * Setting this or leaving this empty will disable this effect. Example: `volumeSmoothness: 0.1`\n * @property {EqualizerBand[]} [equalizerBands] The equalizer bands array for 15 band equalizer.\n * @property {BiquadFilters} [biquadFilter] The biquad filter initializer value\n * @property {boolean} [disableFilters] Disable/enable PCM filter\n * @property {PCMFilters[]} [defaultFilters] The PCM filters initializer\n * @property {Function} [onBeforeCreateStream] Runs before creating stream\n */\nexport interface PlayerOptions {\n    leaveOnEnd?: boolean;\n    leaveOnEndCooldown?: number;\n    leaveOnStop?: boolean;\n    leaveOnEmpty?: boolean;\n    leaveOnEmptyCooldown?: number;\n    autoSelfDeaf?: boolean;\n    ytdlOptions?: downloadOptions;\n    initialVolume?: number;\n    bufferingTimeout?: number;\n    spotifyBridge?: boolean;\n    disableVolume?: boolean;\n    disableEqualizer?: boolean;\n    disableBiquad?: boolean;\n    volumeSmoothness?: number;\n    equalizerBands?: EqualizerBand[];\n    biquadFilter?: BiquadFilters;\n    disableFilters?: boolean;\n    defaultFilters?: PCMFilters[];\n    onBeforeCreateStream?: (track: Track, source: SearchQueryType, queue: Queue) => Promise<Readable>;\n}\n\n/**\n * @typedef {object} ExtractorModelData\n * @property {object} [playlist] The playlist info (if any)\n * @property {string} [playlist.title] The playlist title\n * @property {string} [playlist.description] The playlist description\n * @property {string} [playlist.thumbnail] The playlist thumbnail\n * @property {album|playlist} [playlist.type] The playlist type: `album` | `playlist`\n * @property {TrackSource} [playlist.source] The playlist source\n * @property {object} [playlist.author] The playlist author\n * @property {string} [playlist.author.name] The author name\n * @property {string} [playlist.author.url] The author url\n * @property {string} [playlist.id] The playlist id\n * @property {string} [playlist.url] The playlist url\n * @property {any} [playlist.rawPlaylist] The raw data\n * @property {ExtractorData[]} data The data\n */\n\n/**\n * @typedef {object} ExtractorData\n * @property {string} title The title\n * @property {number} duration The duration\n * @property {string} thumbnail The thumbnail\n * @property {string|Readable|Duplex} engine The stream engine\n * @property {number} views The views count\n * @property {string} author The author\n * @property {string} description The description\n * @property {string} url The url\n * @property {string} [version] The extractor version\n * @property {TrackSource} [source=\"arbitrary\"] The source\n */\nexport interface ExtractorModelData {\n    playlist?: {\n        title: string;\n        description: string;\n        thumbnail: string;\n        type: 'album' | 'playlist';\n        source: TrackSource;\n        author: {\n            name: string;\n            url: string;\n        };\n        id: string;\n        url: string;\n        rawPlaylist?: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n    };\n    data: {\n        title: string;\n        duration: number;\n        thumbnail: string;\n        engine: string | Readable | Duplex;\n        views: number;\n        author: string;\n        description: string;\n        url: string;\n        version?: string;\n        source?: TrackSource;\n    }[];\n}\n\n/**\n * The search query type\n * This can be one of:\n * - AUTO\n * - YOUTUBE\n * - YOUTUBE_PLAYLIST\n * - SOUNDCLOUD_TRACK\n * - SOUNDCLOUD_PLAYLIST\n * - SOUNDCLOUD\n * - SPOTIFY_SONG\n * - SPOTIFY_ALBUM\n * - SPOTIFY_PLAYLIST\n * - FACEBOOK\n * - VIMEO\n * - ARBITRARY\n * - REVERBNATION\n * - YOUTUBE_SEARCH\n * - YOUTUBE_VIDEO\n * - SOUNDCLOUD_SEARCH\n * - APPLE_MUSIC_SONG\n * - APPLE_MUSIC_ALBUM\n * - APPLE_MUSIC_PLAYLIST\n * - FILE\n * @typedef {number} QueryType\n */\nexport const QueryType = {\n    AUTO: 'auto',\n    YOUTUBE: 'youtube',\n    YOUTUBE_PLAYLIST: 'youtubePlaylist',\n    SOUNDCLOUD_TRACK: 'soundcloudTrack',\n    SOUNDCLOUD_PLAYLIST: 'soundcloudPlaylist',\n    SOUNDCLOUD: 'soundcloud',\n    SPOTIFY_SONG: 'spotifySong',\n    SPOTIFY_ALBUM: 'spotifyAlbum',\n    SPOTIFY_PLAYLIST: 'spotifyPlaylist',\n    FACEBOOK: 'facebook',\n    VIMEO: 'vimeo',\n    ARBITRARY: 'arbitrary',\n    REVERBNATION: 'reverbnation',\n    YOUTUBE_SEARCH: 'youtubeSearch',\n    YOUTUBE_VIDEO: 'youtubeVideo',\n    SOUNDCLOUD_SEARCH: 'soundcloudSearch',\n    APPLE_MUSIC_SONG: 'appleMusicSong',\n    APPLE_MUSIC_ALBUM: 'appleMusicAlbum',\n    APPLE_MUSIC_PLAYLIST: 'appleMusicPlaylist',\n    FILE: 'file'\n} as const;\n\nexport type SearchQueryType = keyof typeof QueryType | (typeof QueryType)[keyof typeof QueryType];\n\n/**\n * Emitted when bot gets disconnected from a voice channel\n * @event Player#botDisconnect\n * @param {Queue} queue The queue\n */\n\n/**\n * Emitted when the voice channel is empty\n * @event Player#channelEmpty\n * @param {Queue} queue The queue\n */\n\n/**\n * Emitted when bot connects to a voice channel\n * @event Player#connectionCreate\n * @param {Queue} queue The queue\n * @param {StreamDispatcher} connection The discord player connection object\n */\n\n/**\n * Debug information\n * @event Player#debug\n * @param {Queue} queue The queue\n * @param {string} message The message\n */\n\n/**\n * Emitted on error\n * <warn>This event should handled properly otherwise it may crash your process!</warn>\n * @event Player#error\n * @param {Queue} queue The queue\n * @param {Error} error The error\n */\n\n/**\n * Emitted on connection error. Sometimes stream errors are emitted here as well.\n * @event Player#connectionError\n * @param {Queue} queue The queue\n * @param {Error} error The error\n */\n\n/**\n * Emitted when queue ends\n * @event Player#queueEnd\n * @param {Queue} queue The queue\n */\n\n/**\n * Emitted when a single track is added\n * @event Player#trackAdd\n * @param {Queue} queue The queue\n * @param {Track} track The track\n */\n\n/**\n * Emitted when multiple tracks are added\n * @event Player#tracksAdd\n * @param {Queue} queue The queue\n * @param {Track[]} tracks The tracks\n */\n\n/**\n * Emitted when a track starts playing\n * @event Player#trackStart\n * @param {Queue} queue The queue\n * @param {Track} track The track\n */\n\n/**\n * Emitted when a track ends\n * @event Player#trackEnd\n * @param {Queue} queue The queue\n * @param {Track} track The track\n */\n\n/**\n * Emitted when a track ends\n * @event Player#voiceStateUpdate\n * @param {Queue} queue The queue that this update belongs to\n * @param {VoiceState} oldState The old voice state\n * @param {VoiceState} newState The new voice state\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport interface PlayerEvents {\n    botDisconnect: (queue: Queue) => any;\n    channelEmpty: (queue: Queue) => any;\n    connectionCreate: (queue: Queue, connection: StreamDispatcher) => any;\n    debug: (queue: Queue, message: string) => any;\n    error: (queue: Queue, error: Error) => any;\n    connectionError: (queue: Queue, error: Error) => any;\n    queueEnd: (queue: Queue) => any;\n    trackAdd: (queue: Queue, track: Track) => any;\n    tracksAdd: (queue: Queue, track: Track[]) => any;\n    trackStart: (queue: Queue, track: Track) => any;\n    trackEnd: (queue: Queue, track: Track) => any;\n    voiceStateUpdate: (queue: Queue, oldState: VoiceState, newState: VoiceState) => any;\n}\n\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n/**\n * @typedef {object} PlayOptions\n * @property {boolean} [filtersUpdate=false] If this play was triggered for filters update\n * @property {string[]} [encoderArgs=[]] FFmpeg args passed to encoder\n * @property {number} [seek] Time to seek to before playing\n * @property {boolean} [immediate=false] If it should start playing the provided track immediately\n */\nexport interface PlayOptions {\n    filtersUpdate?: boolean;\n    encoderArgs?: string[];\n    seek?: number;\n    immediate?: boolean;\n}\n\nexport type QueryExtractorSearch = `ext:${string}`;\n\n/**\n * @typedef {object} SearchOptions\n * @property {UserResolvable} requestedBy The user who requested this search\n * @property {typeof QueryType|string} [searchEngine=QueryType.AUTO] The query search engine, can be extractor name to target specific one (custom)\n * @property {boolean} [blockExtractor=false] If it should block custom extractors\n */\nexport interface SearchOptions {\n    requestedBy?: UserResolvable;\n    searchEngine?: SearchQueryType | QueryExtractorSearch;\n    blockExtractor?: boolean;\n}\n\n/**\n * The queue repeat mode. This can be one of:\n * - OFF\n * - TRACK\n * - QUEUE\n * - AUTOPLAY\n * @typedef {number} QueueRepeatMode\n */\nexport enum QueueRepeatMode {\n    OFF = 0,\n    TRACK = 1,\n    QUEUE = 2,\n    AUTOPLAY = 3\n}\n\n/**\n * @typedef {object} PlaylistInitData\n * @property {Track[]} tracks The tracks of this playlist\n * @property {string} title The playlist title\n * @property {string} description The description\n * @property {string} thumbnail The thumbnail\n * @property {album|playlist} type The playlist type: `album` | `playlist`\n * @property {TrackSource} source The playlist source\n * @property {object} author The playlist author\n * @property {string} [author.name] The author name\n * @property {string} [author.url] The author url\n * @property {string} id The playlist id\n * @property {string} url The playlist url\n * @property {any} [rawPlaylist] The raw playlist data\n */\nexport interface PlaylistInitData {\n    tracks: Track[];\n    title: string;\n    description: string;\n    thumbnail: string;\n    type: 'album' | 'playlist';\n    source: TrackSource;\n    author: {\n        name: string;\n        url: string;\n    };\n    id: string;\n    url: string;\n    rawPlaylist?: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n}\n\n/**\n * @typedef {object} TrackJSON\n * @property {string} title The track title\n * @property {string} description The track description\n * @property {string} author The author\n * @property {string} url The url\n * @property {string} thumbnail The thumbnail\n * @property {string} duration The duration\n * @property {number} durationMS The duration in ms\n * @property {number} views The views count\n * @property {Snowflake} requestedBy The id of the user who requested this track\n * @property {PlaylistJSON} [playlist] The playlist info (if any)\n */\nexport interface TrackJSON {\n    id: Snowflake;\n    title: string;\n    description: string;\n    author: string;\n    url: string;\n    thumbnail: string;\n    duration: string;\n    durationMS: number;\n    views: number;\n    requestedBy: Snowflake;\n    playlist?: PlaylistJSON;\n}\n\n/**\n * @typedef {object} PlaylistJSON\n * @property {string} id The playlist id\n * @property {string} url The playlist url\n * @property {string} title The playlist title\n * @property {string} description The playlist description\n * @property {string} thumbnail The thumbnail\n * @property {album|playlist} type The playlist type: `album` | `playlist`\n * @property {TrackSource} source The track source\n * @property {object} author The playlist author\n * @property {string} [author.name] The author name\n * @property {string} [author.url] The author url\n * @property {TrackJSON[]} tracks The tracks data (if any)\n */\nexport interface PlaylistJSON {\n    id: string;\n    url: string;\n    title: string;\n    description: string;\n    thumbnail: string;\n    type: 'album' | 'playlist';\n    source: TrackSource;\n    author: {\n        name: string;\n        url: string;\n    };\n    tracks: TrackJSON[];\n}\n\n/**\n * @typedef {object} PlayerInitOptions\n * @property {boolean} [autoRegisterExtractor=true] If it should automatically register `@discord-player/extractor`\n * @property {YTDLDownloadOptions} [ytdlOptions] The options passed to `ytdl-core`\n * @property {number} [connectionTimeout=20000] The voice connection timeout\n * @property {boolean} [smoothVolume=true] Toggle smooth volume transition\n * @property {boolean} [lagMonitor=30000] Time in ms to re-monitor event loop lag\n */\nexport interface PlayerInitOptions {\n    autoRegisterExtractor?: boolean;\n    ytdlOptions?: downloadOptions;\n    connectionTimeout?: number;\n    smoothVolume?: boolean;\n    lagMonitor?: number;\n}\n","import { StageChannel, VoiceChannel } from 'discord.js';\nimport { TimeData } from '../types/types';\nimport { setTimeout } from 'timers/promises';\n\nclass Util {\n    /**\n     * Utils\n     */\n    private constructor() {} // eslint-disable-line @typescript-eslint/no-empty-function\n\n    /**\n     * Creates duration string\n     * @param {object} durObj The duration object\n     * @returns {string}\n     */\n    static durationString(durObj: Record<string, number>) {\n        return Object.values(durObj)\n            .map((m) => (isNaN(m) ? 0 : m))\n            .join(':');\n    }\n\n    /**\n     * Parses milliseconds to consumable time object\n     * @param {number} milliseconds The time in ms\n     * @returns {TimeData}\n     */\n    static parseMS(milliseconds: number) {\n        if (isNaN(milliseconds)) milliseconds = 0;\n        const round = milliseconds > 0 ? Math.floor : Math.ceil;\n\n        return {\n            days: round(milliseconds / 86400000),\n            hours: round(milliseconds / 3600000) % 24,\n            minutes: round(milliseconds / 60000) % 60,\n            seconds: round(milliseconds / 1000) % 60\n        } as TimeData;\n    }\n\n    /**\n     * Builds time code\n     * @param {TimeData} duration The duration object\n     * @returns {string}\n     */\n    static buildTimeCode(duration: TimeData) {\n        const items = Object.keys(duration);\n        const required = ['days', 'hours', 'minutes', 'seconds'];\n\n        const parsed = items.filter((x) => required.includes(x)).map((m) => duration[m as keyof TimeData]);\n        const final = parsed\n            .slice(parsed.findIndex((x) => x !== 0))\n            .map((x) => x.toString().padStart(2, '0'))\n            .join(':');\n\n        return final.length <= 3 ? `0:${final.padStart(2, '0') || 0}` : final;\n    }\n\n    /**\n     * Picks last item of the given array\n     * @param {any[]} arr The array\n     * @returns {any}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static last<T = any>(arr: T[]): T {\n        if (!Array.isArray(arr)) return arr;\n        return arr[arr.length - 1];\n    }\n\n    /**\n     * Checks if the voice channel is empty\n     * @param {VoiceChannel|StageChannel} channel The voice channel\n     * @returns {boolean}\n     */\n    static isVoiceEmpty(channel: VoiceChannel | StageChannel) {\n        return channel.members.filter((member) => !member.user.bot).size === 0;\n    }\n\n    /**\n     * Safer require\n     * @param {string} id Node require id\n     * @returns {any}\n     */\n    static require(id: string) {\n        try {\n            return require(id);\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Asynchronous timeout\n     * @param {number} time The time in ms to wait\n     * @returns {Promise<unknown>}\n     */\n    static wait(time: number) {\n        return setTimeout(time, undefined, { ref: false });\n    }\n\n    static noop() {} // eslint-disable-line @typescript-eslint/no-empty-function\n\n    static async getFetch() {\n        if ('fetch' in globalThis) return globalThis.fetch;\n        for (const lib of ['node-fetch', 'undici']) {\n            try {\n                return await import(lib).then((res) => res.fetch || res.default?.fetch || res.default);\n            } catch {\n                try {\n                    // eslint-disable-next-line\n                    const res = require(lib);\n                    if (res) return res.fetch || res.default?.fetch || res.default;\n                } catch {\n                    // no?\n                }\n            }\n        }\n    }\n}\n\nexport { Util };\n","export enum ErrorStatusCode {\n    STREAM_ERROR = 'StreamError',\n    AUDIO_PLAYER_ERROR = 'AudioPlayerError',\n    PLAYER_ERROR = 'PlayerError',\n    NO_AUDIO_RESOURCE = 'NoAudioResource',\n    UNKNOWN_GUILD = 'UnknownGuild',\n    INVALID_ARG_TYPE = 'InvalidArgType',\n    UNKNOWN_EXTRACTOR = 'UnknownExtractor',\n    INVALID_EXTRACTOR = 'InvalidExtractor',\n    INVALID_CHANNEL_TYPE = 'InvalidChannelType',\n    INVALID_TRACK = 'InvalidTrack',\n    UNKNOWN_REPEAT_MODE = 'UnknownRepeatMode',\n    TRACK_NOT_FOUND = 'TrackNotFound',\n    NO_CONNECTION = 'NoConnection',\n    DESTROYED_QUEUE = 'DestroyedQueue'\n}\n\nexport class PlayerError extends Error {\n    message: string;\n    statusCode: ErrorStatusCode;\n    createdAt = new Date();\n\n    constructor(message: string, code: ErrorStatusCode = ErrorStatusCode.PLAYER_ERROR) {\n        super();\n\n        this.message = `[${code}] ${message}`;\n        this.statusCode = code;\n        this.name = code;\n\n        Error.captureStackTrace(this);\n    }\n\n    get createdTimestamp() {\n        return this.createdAt.getTime();\n    }\n\n    valueOf() {\n        return this.statusCode;\n    }\n\n    toJSON() {\n        return {\n            stack: this.stack,\n            code: this.statusCode,\n            message: this.message,\n            created: this.createdTimestamp\n        };\n    }\n\n    toString() {\n        return this.stack;\n    }\n}\n","import { FFmpeg } from 'prism-media';\nimport type { Duplex, Readable } from 'stream';\n\nexport interface FFmpegStreamOptions {\n    fmt?: string;\n    encoderArgs?: string[];\n    seek?: number;\n    skip?: boolean;\n}\n\nexport function FFMPEG_ARGS_STRING(stream: string, fmt?: string) {\n    // prettier-ignore\n    return [\n        \"-reconnect\", \"1\",\n        \"-reconnect_streamed\", \"1\",\n        \"-reconnect_delay_max\", \"5\",\n        \"-i\", stream,\n        \"-analyzeduration\", \"0\",\n        \"-loglevel\", \"0\",\n        \"-f\", `${typeof fmt === \"string\" ? fmt : \"s16le\"}`,\n        \"-ar\", \"48000\",\n        \"-ac\", \"2\"\n    ];\n}\n\nexport function FFMPEG_ARGS_PIPED(fmt?: string) {\n    // prettier-ignore\n    return [\n        \"-analyzeduration\", \"0\",\n        \"-loglevel\", \"0\",\n        \"-f\", `${typeof fmt === \"string\" ? fmt : \"s16le\"}`,\n        \"-ar\", \"48000\",\n        \"-ac\", \"2\"\n    ];\n}\n\n/**\n * Creates FFmpeg stream\n * @param stream The source stream\n * @param options FFmpeg stream options\n */\nexport function createFFmpegStream(stream: Readable | Duplex | string, options?: FFmpegStreamOptions) {\n    if (options?.skip && typeof stream !== 'string') return stream;\n    options ??= {};\n    const args = typeof stream === 'string' ? FFMPEG_ARGS_STRING(stream, options.fmt) : FFMPEG_ARGS_PIPED(options.fmt);\n\n    if (!Number.isNaN(options.seek)) args.unshift('-ss', String(options.seek));\n    if (Array.isArray(options.encoderArgs)) args.push(...options.encoderArgs);\n\n    const transcoder = new FFmpeg({ shell: false, args });\n    transcoder.on('close', () => transcoder.destroy());\n\n    if (typeof stream !== 'string') {\n        stream.on('error', () => transcoder.destroy());\n        stream.pipe(transcoder);\n    }\n\n    return transcoder;\n}\n","import { YouTube } from 'youtube-sr';\nimport { QueryType } from '../types/types';\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport { validateURL as SoundcloudValidateURL } from 'soundcloud-scraper';\n\n// #region scary things below *sigh*\nconst spotifySongRegex = /^https?:\\/\\/(?:embed\\.|open\\.)(?:spotify\\.com\\/)(?:track\\/|\\?uri=spotify:track:)((\\w|-){22})(\\?si=.+)?$/;\nconst spotifyPlaylistRegex = /^https?:\\/\\/(?:embed\\.|open\\.)(?:spotify\\.com\\/)(?:playlist\\/|\\?uri=spotify:playlist:)((\\w|-){22})(\\?si=.+)?$/;\nconst spotifyAlbumRegex = /^https?:\\/\\/(?:embed\\.|open\\.)(?:spotify\\.com\\/)(?:album\\/|\\?uri=spotify:album:)((\\w|-){22})(\\?si=.+)?$/;\nconst vimeoRegex = /^(http|https)?:\\/\\/(www\\.|player\\.)?vimeo\\.com\\/(?:channels\\/(?:\\w+\\/)?|groups\\/([^/]*)\\/videos\\/|video\\/|)(\\d+)(?:|\\/\\?)$/;\nconst reverbnationRegex = /^https:\\/\\/(www.)?reverbnation.com\\/(.+)\\/song\\/(.+)$/;\nconst attachmentRegex = /^https?:\\/\\/.+$/;\nconst appleMusicSongRegex = /^https?:\\/\\/music\\.apple\\.com\\/.+?\\/(song|album)\\/.+?(\\/.+?\\?i=|\\/)([0-9]+)$/;\nconst appleMusicPlaylistRegex = /^https?:\\/\\/music\\.apple\\.com\\/.+?\\/playlist\\/.+\\/pl\\.[a-f0-9]+$/;\nconst appleMusicAlbumRegex = /^https?:\\/\\/music\\.apple\\.com\\/.+?\\/album\\/.+\\/([0-9]+)$/;\n// #endregion scary things above *sigh*\n\nclass QueryResolver {\n    /**\n     * Query resolver\n     */\n    private constructor() {} // eslint-disable-line @typescript-eslint/no-empty-function\n\n    static get regex() {\n        return {\n            spotifyAlbumRegex,\n            spotifyPlaylistRegex,\n            spotifySongRegex,\n            vimeoRegex,\n            reverbnationRegex,\n            attachmentRegex,\n            appleMusicAlbumRegex,\n            appleMusicPlaylistRegex,\n            appleMusicSongRegex\n        };\n    }\n\n    /**\n     * Resolves the given search query\n     * @param {string} query The query\n     * @returns {QueryType}\n     */\n    static resolve(query: string): (typeof QueryType)[keyof typeof QueryType] {\n        query = query.trim();\n        if (SoundcloudValidateURL(query, 'track')) return QueryType.SOUNDCLOUD_TRACK;\n        if (SoundcloudValidateURL(query, 'playlist') || query.includes('/sets/')) return QueryType.SOUNDCLOUD_PLAYLIST;\n        if (YouTube.isPlaylist(query)) return QueryType.YOUTUBE_PLAYLIST;\n        if (QueryResolver.validateId(query) || QueryResolver.validateURL(query)) return QueryType.YOUTUBE_VIDEO;\n        if (spotifySongRegex.test(query)) return QueryType.SPOTIFY_SONG;\n        if (spotifyPlaylistRegex.test(query)) return QueryType.SPOTIFY_PLAYLIST;\n        if (spotifyAlbumRegex.test(query)) return QueryType.SPOTIFY_ALBUM;\n        if (vimeoRegex.test(query)) return QueryType.VIMEO;\n        if (reverbnationRegex.test(query)) return QueryType.REVERBNATION;\n        if (appleMusicAlbumRegex.test(query)) return QueryType.APPLE_MUSIC_ALBUM;\n        if (appleMusicPlaylistRegex.test(query)) return QueryType.APPLE_MUSIC_PLAYLIST;\n        if (appleMusicSongRegex.test(query)) return QueryType.APPLE_MUSIC_SONG;\n        if (attachmentRegex.test(query)) return QueryType.ARBITRARY;\n\n        return QueryType.YOUTUBE_SEARCH;\n    }\n\n    /**\n     * Parses vimeo id from url\n     * @param {string} query The query\n     * @returns {string}\n     */\n    static getVimeoID(query: string): string | null | undefined {\n        return QueryResolver.resolve(query) === QueryType.VIMEO\n            ? query\n                  .split('/')\n                  .filter((x) => !!x)\n                  .pop()\n            : null;\n    }\n\n    static validateId(q: string) {\n        return YouTube.Regex.VIDEO_ID.test(q);\n    }\n\n    static validateURL(q: string) {\n        return YouTube.Regex.VIDEO_URL.test(q);\n    }\n}\n\nexport { QueryResolver };\n","import { VoiceChannel, StageChannel, Snowflake } from 'discord.js';\nimport { DiscordGatewayAdapterCreator, joinVoiceChannel, VoiceConnection } from '@discordjs/voice';\nimport { StreamDispatcher } from './StreamDispatcher';\nimport { Collection } from '@discord-player/utils';\n\nclass VoiceUtils {\n    public cache: Collection<Snowflake, StreamDispatcher>;\n\n    /**\n     * The voice utils\n     * @private\n     */\n    constructor() {\n        /**\n         * The cache where voice utils stores stream managers\n         * @type {Collection<Snowflake, StreamDispatcher>}\n         */\n        this.cache = new Collection<Snowflake, StreamDispatcher>();\n    }\n\n    /**\n     * Joins a voice channel, creating basic stream dispatch manager\n     * @param {StageChannel|VoiceChannel} channel The voice channel\n     * @param {object} [options] Join options\n     * @returns {Promise<StreamDispatcher>}\n     */\n    public async connect(\n        channel: VoiceChannel | StageChannel,\n        options?: {\n            deaf?: boolean;\n            maxTime?: number;\n        }\n    ): Promise<StreamDispatcher> {\n        const conn = await this.join(channel, options);\n        const sub = new StreamDispatcher(conn, channel, options?.maxTime);\n        this.cache.set(channel.guild.id, sub);\n        return sub;\n    }\n\n    /**\n     * Joins a voice channel\n     * @param {StageChannel|VoiceChannel} [channel] The voice/stage channel to join\n     * @param {object} [options] Join options\n     * @returns {VoiceConnection}\n     */\n    public async join(\n        channel: VoiceChannel | StageChannel,\n        options?: {\n            deaf?: boolean;\n            maxTime?: number;\n        }\n    ) {\n        const conn = joinVoiceChannel({\n            guildId: channel.guild.id,\n            channelId: channel.id,\n            adapterCreator: channel.guild.voiceAdapterCreator as unknown as DiscordGatewayAdapterCreator,\n            selfDeaf: Boolean(options?.deaf)\n        });\n\n        return conn;\n    }\n\n    /**\n     * Disconnects voice connection\n     * @param {VoiceConnection} connection The voice connection\n     * @returns {void}\n     */\n    public disconnect(connection: VoiceConnection | StreamDispatcher) {\n        if (connection instanceof StreamDispatcher) return connection.voiceConnection.destroy();\n        return connection.destroy();\n    }\n\n    /**\n     * Returns Discord Player voice connection\n     * @param {Snowflake} guild The guild id\n     * @returns {StreamDispatcher}\n     */\n    public getConnection(guild: Snowflake) {\n        return this.cache.get(guild);\n    }\n}\n\nexport { VoiceUtils };\n","import {\n    AudioPlayer,\n    AudioPlayerError,\n    AudioPlayerStatus,\n    AudioResource,\n    createAudioPlayer,\n    createAudioResource,\n    entersState,\n    StreamType,\n    VoiceConnection,\n    VoiceConnectionStatus,\n    VoiceConnectionDisconnectReason\n} from '@discordjs/voice';\nimport { StageChannel, VoiceChannel } from 'discord.js';\nimport { Duplex, Readable } from 'stream';\nimport { TypedEmitter as EventEmitter } from 'tiny-typed-emitter';\nimport Track from '../Structures/Track';\nimport { Util } from '../utils/Util';\nimport { PlayerError, ErrorStatusCode } from '../Structures/PlayerError';\nimport { EqualizerBand, EqualizerStream, BiquadStream, BiquadFilters, AudioFilter, PCMFilters } from '@discord-player/equalizer';\n\ninterface CreateStreamOps {\n    type?: StreamType;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data?: any;\n    disableVolume?: boolean;\n    disableEqualizer?: boolean;\n    disableBiquad?: boolean;\n    eq?: EqualizerBand[];\n    biquadFilter?: BiquadFilters;\n    disableFilters?: boolean;\n    defaultFilters?: PCMFilters[];\n}\n\nexport interface VoiceEvents {\n    /* eslint-disable @typescript-eslint/no-explicit-any */\n    error: (error: AudioPlayerError) => any;\n    debug: (message: string) => any;\n    start: (resource: AudioResource<Track>) => any;\n    finish: (resource: AudioResource<Track>) => any;\n    audioFilters: (filters: PCMFilters[]) => any;\n    /* eslint-enable @typescript-eslint/no-explicit-any */\n}\n\nclass StreamDispatcher extends EventEmitter<VoiceEvents> {\n    public readonly voiceConnection: VoiceConnection;\n    public readonly audioPlayer: AudioPlayer;\n    public channel: VoiceChannel | StageChannel;\n    public audioResource?: AudioResource<Track> | null;\n    private readyLock = false;\n    public equalizer: EqualizerStream | null = null;\n    public biquad: BiquadStream | null = null;\n    public audioFilters: AudioFilter | null = null;\n\n    /**\n     * Creates new connection object\n     * @param {VoiceConnection} connection The connection\n     * @param {VoiceChannel|StageChannel} channel The connected channel\n     * @private\n     */\n    constructor(connection: VoiceConnection, channel: VoiceChannel | StageChannel, public readonly connectionTimeout: number = 20000) {\n        super();\n\n        /**\n         * The voice connection\n         * @type {VoiceConnection}\n         */\n        this.voiceConnection = connection;\n\n        /**\n         * The audio player\n         * @type {AudioPlayer}\n         */\n        this.audioPlayer = createAudioPlayer();\n\n        /**\n         * The voice channel\n         * @type {VoiceChannel|StageChannel}\n         */\n        this.channel = channel;\n\n        this.voiceConnection.on('stateChange', async (_, newState) => {\n            if (newState.status === VoiceConnectionStatus.Disconnected) {\n                if (newState.reason === VoiceConnectionDisconnectReason.WebSocketClose && newState.closeCode === 4014) {\n                    try {\n                        await entersState(this.voiceConnection, VoiceConnectionStatus.Connecting, this.connectionTimeout);\n                    } catch {\n                        try {\n                            this.voiceConnection.destroy();\n                        } catch (err) {\n                            this.emit('error', err as AudioPlayerError);\n                        }\n                    }\n                } else if (this.voiceConnection.rejoinAttempts < 5) {\n                    await Util.wait((this.voiceConnection.rejoinAttempts + 1) * 5000);\n                    this.voiceConnection.rejoin();\n                } else {\n                    try {\n                        this.voiceConnection.destroy();\n                    } catch (err) {\n                        this.emit('error', err as AudioPlayerError);\n                    }\n                }\n            } else if (newState.status === VoiceConnectionStatus.Destroyed) {\n                this.end();\n            } else if (!this.readyLock && (newState.status === VoiceConnectionStatus.Connecting || newState.status === VoiceConnectionStatus.Signalling)) {\n                this.readyLock = true;\n                try {\n                    await entersState(this.voiceConnection, VoiceConnectionStatus.Ready, this.connectionTimeout);\n                } catch {\n                    if (this.voiceConnection.state.status !== VoiceConnectionStatus.Destroyed) {\n                        try {\n                            this.voiceConnection.destroy();\n                        } catch (err) {\n                            this.emit('error', err as AudioPlayerError);\n                        }\n                    }\n                } finally {\n                    this.readyLock = false;\n                }\n            }\n        });\n\n        this.audioPlayer.on('stateChange', (oldState, newState) => {\n            if (newState.status === AudioPlayerStatus.Playing) {\n                if (!this.paused) return void this.emit('start', this.audioResource!);\n            } else if (newState.status === AudioPlayerStatus.Idle && oldState.status !== AudioPlayerStatus.Idle) {\n                if (!this.paused) {\n                    void this.emit('finish', this.audioResource!);\n                    if (this.equalizer) {\n                        this.equalizer.destroy();\n                        this.equalizer = null;\n                    }\n                    if (this.biquad) {\n                        this.biquad.destroy();\n                        this.biquad = null;\n                    }\n                    if (this.audioFilters) {\n                        this.audioFilters.destroy();\n                        this.audioFilters = null;\n                    }\n                    this.audioResource = null;\n                }\n            }\n        });\n\n        this.audioPlayer.on('debug', (m) => void this.emit('debug', m));\n        this.audioPlayer.on('error', (error) => void this.emit('error', error));\n        this.voiceConnection.subscribe(this.audioPlayer);\n    }\n\n    /**\n     * Check if the player has been paused manually\n     */\n    get paused() {\n        return this.audioPlayer.state.status === AudioPlayerStatus.Paused;\n    }\n\n    set paused(val: boolean) {\n        val ? this.pause(true) : this.resume();\n    }\n\n    /**\n     * Whether or not the player is currently paused automatically or manually.\n     */\n    isPaused() {\n        return this.paused || this.audioPlayer.state.status === AudioPlayerStatus.AutoPaused;\n    }\n\n    /**\n     * Whether or not the player is currently buffering\n     */\n    isBuffering() {\n        return this.audioPlayer.state.status === AudioPlayerStatus.Buffering;\n    }\n\n    /**\n     * Whether or not the player is currently playing\n     */\n    isPlaying() {\n        return this.audioPlayer.state.status === AudioPlayerStatus.Playing;\n    }\n\n    /**\n     * Whether or not the player is currently idle\n     */\n    isIdle() {\n        return this.audioPlayer.state.status === AudioPlayerStatus.Idle;\n    }\n\n    /**\n     * Creates stream\n     * @param {Readable|Duplex|string} src The stream source\n     * @param {object} [ops] Options\n     * @returns {AudioResource}\n     */\n    createStream(src: Readable | Duplex | string, ops?: CreateStreamOps) {\n        if (!ops?.disableEqualizer) {\n            this.equalizer = new EqualizerStream({\n                channels: 1,\n                disabled: false,\n                bandMultiplier: ops?.eq || []\n            });\n        }\n\n        if (!ops?.disableBiquad) {\n            this.biquad = new BiquadStream({\n                filter: ops?.biquadFilter\n            });\n        }\n\n        if (!ops?.disableFilters) {\n            this.audioFilters = new AudioFilter({\n                filters: ops?.defaultFilters\n            });\n            this.audioFilters.onUpdate = () => {\n                if (this.audioFilters) this.emit('audioFilters', this.audioFilters.filters);\n            };\n        }\n\n        let stream = this.equalizer && typeof src !== 'string' ? src.pipe(this.equalizer) : src;\n        if (this.biquad && typeof stream !== 'string') stream = stream.pipe(this.biquad);\n        if (this.audioFilters && typeof stream !== 'string') stream = stream.pipe(this.audioFilters);\n\n        this.audioResource = createAudioResource(stream, {\n            inputType: ops?.type ?? StreamType.Arbitrary,\n            metadata: ops?.data,\n            inlineVolume: !ops?.disableVolume\n        });\n\n        return this.audioResource;\n    }\n\n    /**\n     * The player status\n     * @type {AudioPlayerStatus}\n     */\n    get status() {\n        return this.audioPlayer.state.status;\n    }\n\n    /**\n     * Disconnects from voice\n     * @returns {void}\n     */\n    disconnect() {\n        try {\n            this.audioPlayer.stop(true);\n            this.voiceConnection.destroy();\n        } catch {} // eslint-disable-line no-empty\n    }\n\n    /**\n     * Stops the player\n     * @returns {void}\n     */\n    end() {\n        this.audioPlayer.stop();\n    }\n\n    /**\n     * Pauses the stream playback\n     * @param {boolean} [interpolateSilence=false] If true, the player will play 5 packets of silence after pausing to prevent audio glitches.\n     * @returns {boolean}\n     */\n    pause(interpolateSilence?: boolean) {\n        const success = this.audioPlayer.pause(interpolateSilence);\n        return success;\n    }\n\n    /**\n     * Resumes the stream playback\n     * @returns {boolean}\n     */\n    resume() {\n        const success = this.audioPlayer.unpause();\n        return success;\n    }\n\n    /**\n     * Play stream\n     * @param {AudioResource<Track>} [resource=this.audioResource] The audio resource to play\n     * @returns {Promise<StreamDispatcher>}\n     */\n    async playStream(resource: AudioResource<Track> = this.audioResource!) {\n        if (!resource) throw new PlayerError('Audio resource is not available!', ErrorStatusCode.NO_AUDIO_RESOURCE);\n        if (resource.ended) {\n            return void this.emit('finish', resource);\n        }\n        if (!this.audioResource) this.audioResource = resource;\n        if (this.voiceConnection.state.status !== VoiceConnectionStatus.Ready) {\n            try {\n                await entersState(this.voiceConnection, VoiceConnectionStatus.Ready, this.connectionTimeout);\n            } catch (err) {\n                return void this.emit('error', err as AudioPlayerError);\n            }\n        }\n\n        try {\n            this.audioPlayer.play(resource);\n        } catch (e) {\n            this.emit('error', e as AudioPlayerError);\n        }\n\n        return this;\n    }\n\n    /**\n     * Sets playback volume\n     * @param {number} value The volume amount\n     * @returns {boolean}\n     */\n    setVolume(value: number) {\n        if (!this.audioResource?.volume || isNaN(value) || value < 0 || value > Infinity) return false;\n\n        this.audioResource.volume.setVolumeLogarithmic(value / 100);\n        return true;\n    }\n\n    /**\n     * The current volume\n     * @type {number}\n     */\n    get volume() {\n        if (!this.audioResource?.volume) return 100;\n        const currentVol = this.audioResource.volume.volume;\n        return Math.round(Math.pow(currentVol, 1 / 1.660964) * 100);\n    }\n\n    /**\n     * The playback time\n     * @type {number}\n     */\n    get streamTime() {\n        if (!this.audioResource) return 0;\n        return this.audioResource.playbackDuration;\n    }\n}\n\nexport { StreamDispatcher as StreamDispatcher };\n","import { User } from 'discord.js';\nimport { BaseExtractor } from '../extractors/BaseExtractor';\nimport { Player } from '../Player';\nimport { QueryExtractorSearch, QueryType, SearchQueryType } from '../types/types';\nimport { Playlist } from './Playlist';\nimport Track from './Track';\n\nexport interface SearchResultData {\n    query: string;\n    queryType?: SearchQueryType | QueryExtractorSearch | null;\n    extractor?: BaseExtractor | null;\n    playlist?: Playlist | null;\n    tracks?: Track[];\n    requestedBy?: User | null;\n}\n\nexport class SearchResult {\n    public constructor(public player: Player, private _data: SearchResultData) {}\n\n    public get query() {\n        return this._data.query;\n    }\n\n    public get queryType() {\n        return this._data.queryType || QueryType.AUTO;\n    }\n\n    public get extractor() {\n        return this._data.extractor || null;\n    }\n\n    public get playlist() {\n        return this._data.playlist;\n    }\n\n    public get tracks() {\n        return this._data.tracks || [];\n    }\n\n    public get requestedBy() {\n        return this._data.requestedBy || null;\n    }\n\n    public async execute() {\n        return this.player.search(this.query, {\n            searchEngine: this.queryType,\n            requestedBy: this.requestedBy!\n        });\n    }\n\n    public isEmpty() {\n        return !this.tracks.length;\n    }\n\n    public hasPlaylist() {\n        return this.playlist != null;\n    }\n\n    public hasTracks() {\n        return this.tracks.length > 0;\n    }\n\n    public toJSON() {\n        return {\n            query: this.query,\n            queryType: this.queryType,\n            playlist: this.playlist?.toJSON(false) || null,\n            tracks: this.tracks.map((m) => m.toJSON(true)),\n            extractor: this.extractor?.identifier || null,\n            requestedBy: this.requestedBy?.toJSON() || null\n        };\n    }\n}\n"],"mappings":"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","names":["import_discord","import_discord","import_tiny_typed_emitter","import_discord","QueueRepeatMode","ErrorStatusCode","import_utils","SoundcloudValidateURL","import_youtube_sr","streamTime","os","import_voice","import_voice","EventEmitter","import_utils","import_voice","import_utils","EventEmitter","djsVersion"]}